<?php
// $Id:$

function tree_node_info() {
  return array(
    'tree' => array(
      'name' => t('Phylogenetic tree'),
      'module' => 'tree',
      'description' => t("Draws phylogenetic trees"),
    )
  );
}

/**
 * Implementation of hook_access().
 *
 * Node modules may implement node_access() to determine the operations
 * users may perform on nodes. This example uses a very common access pattern.
 */
function tree_access($op, $node) {
  global $user;

  if ($op == 'create') {
    // Only users with permission to do so may create this node type.
    return user_access('create node');
  }

  // Users who create a node may edit or delete it later, assuming they have the
  // necessary permissions.
  if ($op == 'update' || $op == 'delete') {
    if (user_access('edit own nodes') && ($user->uid == $node->uid)) {
      return TRUE;
    }
  }
}

/**
 * Implementation of hook_form().
 *
 * Now it's time to describe the form for collecting the information
 * specific to this node type. This hook requires us to return an array with
 * a sub array containing information for each element in the form.
 */
function tree_form(&$node) {
  $type = node_get_types('type', $node);

  // We need to define form elements for the node's title and body.
  $form['title'] = array(
    '#type' => 'textfield',
    '#title' => check_plain($type->title_label),
    '#required' => TRUE,
    '#default_value' => $node->title,
    '#weight' => -5
  );
  // We want the body and filter elements to be adjacent. We could try doing
  // this by setting their weights, but another module might add elements to the
  // form with the same weights and end up between ours. By putting them into a
  // sub-array together, we're able force them to be rendered together.
  $form['body'] = array(
    '#type' => 'textarea',
    '#title' => check_plain($type->body_label),
    '#default_value' => $node->body,
    '#required' => FALSE
  );
  return $form;
}

/**
 * Implementation of hook_update().
 *
 * As an existing node is being updated in the database, we need to do our own
 * database updates.
 */
function tree_update($node) {
  // Executes the "tvwidget" program on a temp file which will give us the output shit!
  $filepath = file_create_filename('tree', file_directory_temp());
  file_save_data($node->body, $filepath, FILE_EXISTS_REPLACE);
  // Execute the magic tvwidget and save the shit
  $path = file_directory_path().'/tree-'.$node->nid;
  file_check_directory($path, true);
  $exec_string = $_SERVER['DOCUMENT_ROOT'].'/'.drupal_get_path('module','tree').'/tvwidget -o '.$path.' -b /files/tree-'.$node->nid.' '.$filepath;
  exec($exec_string);
  echo $exec_string;
  file_delete($filepath);
}

/**
 * Implementation of hook_view().
 *
 * This is a typical implementation that simply runs the node text through
 * the output filters.
 */
function tree_view($node, $teaser = FALSE, $page = FALSE) {
  $node = node_prepare($node, $teaser);
  $node->content['myfield'] = array(
    '#value' => theme('tree_order_info', $node),
    '#weight' => 1,
  );

  return $node;
}

/**
 * A custom theme function.
 *
 * By using this function to format our node-specific information, themes
 * can override this presentation if they wish. We also wrap the default
 * presentation in a CSS class that is prefixed by the module name. This
 * way, style sheets can modify the output without requiring theme code.
 */
function theme_tree_order_info($node) {
  $output = '<div class="tree_order_info">';
  $output .= t('The order is for %quantity %color items.', array('%quantity' => check_plain($node->quantity), '%color' => check_plain($node->color)));
  $output .= '</div>';
  return $output;
}