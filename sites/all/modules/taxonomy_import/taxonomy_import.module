<?php
/* $Id$ */

/** 
 * @file taxonomy_import.module
 * This module makes it possible to import and export taxonomies
 */

/** 
 * Implementation of hook_menu: Define menu links.
 * 
 * @note See hook_menu for a description of parameters and return values.
 */
function taxonomy_import_menu() {
  $items['admin/content/taxonomy/export'] = array(
    'title' => 'Export',
    'access arguments' => array('administer taxonomy'),
    'page callback' => 'taxonomy_import_export',
    'type' => MENU_LOCAL_TASK);
  $items['admin/content/taxonomy/import'] = array(
    'title' => 'Import',
    'access arguments' => array('administer taxonomy'),
    'page callback' => 'taxonomy_import_import',
    'type' => MENU_LOCAL_TASK);
  return $items;
}

/**
 * Menu callback for exporting shit
 */
function taxonomy_import_export(){
  return drupal_get_form('taxonomy_import_export_form');
}
/**
 * Menu callback for the import page.
 */
function taxonomy_import_import() {
  return drupal_get_form('taxonomy_import_import_form');
}

/**
 * Imports the actual file.
 */
function taxonomy_import_import_form_validate($form, &$form_state) {
  if ($form_state['values']['vid'] == 0){
    form_set_error('vid',t('Please select a Vocabulary'));
  }
  if ($form_state['values']['taxonomic_name'] =="Scratchy scratchpadae" || $form_state['values']['taxonomic_name']==""){
    if($form_state['values']['import_format'] == 0){
      form_set_error('import_format',t('Please select a File Format'));
    }
    
    if ($file = file_save_upload('data')){
      $fd = fopen($file->filepath, "rb");
  	  $info = fstat($fd);
  	  $len = $info["size"];
  	  $text = fread($fd, $len);
	    fclose($fd);
      if(!$fd)
        form_set_error('data', t('Vocabulary import failed: file %filename cannot be read.', array('%filename' => $file->filename)));      
      else{
        //taxonomy_import_parse($text, $form_state['values']['vid'], $form_state['values']['import_format']);
        // Remove the following line if you'd like users to specify the fileformat
        taxonomy_import_parse($text, $form_state['values']['vid'], $form_state['values']['import_format']);
      }
    }
    else
      form_set_error('data', t('Vocabulary import failed: file was not uploaded.'));
  }
  else{
    drupal_set_message('Downloaded file from uBio');
    taxonomy_import_ubio_import($form_state['values']['taxonomic_name'],$form_state['values']['classification'],$form_state['values']['vid']);
  }
}


/**
 * Imports the taxonomic classification from uBio
 */
function taxonomy_import_ubio_import($taxonomic_name,$classification, $vid, $xml = false){
  // Possibly add this in future to an admin interface
  // http://www.ubio.org/webservices/classificationbank/search.php?classification=[classification]&node=[taxonomic_name]
  $url = 'http://www.ubio.org/webservices/classificationbank/search.php?classification='.$classification.'&node='.$taxonomic_name; 
  
  function startElement($parser, $name, $attrs)
  {   
    global $parser_depth;
    global $xml_converted;
    global $in_synonym;
    global $in_name_without_canonical;
    if ($name == "NAME"  && !$in_synonym){
      for ($i = 0; $i < $parser_depth-1; $i++) {
          $xml_converted .= "\t";
      }
      if(isset($attrs['CANONICALFORM']) && $attrs['CANONICALFORM'] != ''){
        $xml_converted .= $attrs['CANONICALFORM']."\n";
      } else {
        // The canonical form is blank, there is probably no authority, so 
        // we should use the full name
        $in_name_without_canonical = true;
      }
    }
    if($name == "SYNONYMS"){
      $in_synonym = true;
    }
    if ($name == "NODES"){ 
      $parser_depth++;
    }
  }
  
  function stringElement($parser, $data){
    global $in_name_without_canonical;
    global $xml_converted;
    if($in_name_without_canonical){
      $xml_converted .= "$data\n";
    }
  }
  
  function endElement($parser, $name)
  {
    global $in_synonym;
    global $in_name_without_canonical;
    $in_name_without_canonical = false;
    if ($name=="NODES"){
      global $parser_depth;
      $parser_depth--;
    }
    if($name == "SYNONYMS"){
      $in_synonym = false;
    }
  }
  
  if (!$xml){
    $headers = array();
    $result = drupal_http_request($url, $headers);
    if ($result->code=="200"){
      // Success, do stuff with results
      $xml = $result->data;
    }
    else {
      form_set_error('taxonomic_name', t('We were unable to load a classification for you, please check the uBio site for the name you entered.'));    
    }
  }
  if ($xml && $xml !=''){    
    $xml_parser = xml_parser_create();
    xml_set_element_handler($xml_parser, "startElement", "endElement");
    xml_set_character_data_handler  ($xml_parser, "stringElement");
    $lines = preg_split("/[\n\r]+/", $xml);
    $xml_converted ="";
    if (trim($lines[1])=="IMPORT FROM SERVER FILE"){
      // get contents of a file into a string
      $handle = fopen(trim($lines[2]), "r");
      while (!feof($handle)) {
        xml_parse($xml_parser, fread($handle, 8192));
      }
      fclose($handle);
    }
    else {
      foreach ($lines as $line) {
        xml_parse($xml_parser, utf8_encode($line));// Should add error handling here!
      }
    }
    global $xml_converted;
    xml_parser_free($xml_parser);  
    taxonomy_import_parse($xml_converted, $vid, 2);
  }
}

function taxonomy_import_export_form_submit($form, &$form_state){
  header('Content-Type: text/tab-separated-values');
  header('Content-Disposition: attachment; filename=taxonomyexport.txt');
  _taxonomy_import_recurse_export(0,$values['vid']);
  exit;
}
function _taxonomy_import_recurse_export($tid, $vid){
  $results = db_query('
    SELECT
      td.tid tid,
      td.name child,
      td.description description,
      p.name parent
    FROM 
      term_data td 
    INNER JOIN 
      term_hierarchy th ON td.tid = th.tid 
    LEFT JOIN
      term_data p ON p.tid = th.parent
    WHERE 
      td.vid = %d AND
      th.parent = %d',$vid, $tid);
  while($row = db_fetch_array($results)){
    echo $row['child']."\t".$row['parent']."\t".$row['description']."\n";
    _taxonomy_import_recurse_export($row['tid'],$vid);
  }
}
/**
 * Builds the export form.
 */
function taxonomy_import_export_form(&$form_state){
  
  foreach (module_invoke('taxonomy', 'get_vocabularies') as $vid => $voc) {
    $vocs[$vid] = $voc->name;
  }
  $form['vid'] = array(
    '#type' => 'select',
    '#title' => t('Export vocabulary'),
    '#options' => $vocs,
    '#description' => t('The vocabulary which you would like to export.'),
  );
  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Export'),
  );
  return $form;
}
/**
 * Builds the import form.
 */
function taxonomy_import_import_form(&$form_state) {
  $vocs[0] = "- SELECT VOCABULARY -";
  foreach (module_invoke('taxonomy', 'get_vocabularies') as $vid => $voc) {
    $vocs[$vid] = $voc->name;
  }
  $form['vid'] = array(
    '#type' => 'select',
    '#title' => t('Target vocabulary'),
    '#options' => $vocs,
    '#description' => t('The vocabulary into which terms should be loaded.'),
  );
  $form['file_import'] = array(
    '#type' => 'fieldset',
    '#title' => 'Import from file'
  );
  // Uncomment if you'd like users to specify
  $ifopts = array(0=>"- FILE FORMAT -",1=>"Parent Child",2=>"Tabbed list",3=>"Full hierarchy");
  $form['file_import']['import_format'] = array(
    '#type' => 'select',
    '#title' => t('Input file format'),
    '#options' => $ifopts,
    '#description' => t('The file format of the vocabulary being imported'));
  
  $form['file_import']['data'] = array(
    '#type' => 'file',
    '#title' => t('File to import'),
    '#description' => t('Click "Browse..." to select a file to upload.'),
    '#required' => FALSE
  );
  $form['ubio_import'] = array(
    '#type' => 'fieldset',
    '#title' => '<b>OR</b> Import directly from uBio'
  );
  $form['ubio_import']['classification'] = array(
    '#type' => 'select',
    '#title' => t('Classification'),
    '#options' => array ("sp2000"=>"Species2000","ncbi"=>"NCBI","itis"=>"ITIS")
  );
  $form['ubio_import']['taxonomic_name'] = array(
    '#type' => 'textfield',
    '#title' => t('Highest taxonomic name of relevance to this site'),
    '#description' => t('This should be a taxonomic name which is the parent of all the taxa which are being studied on this site.'),
    '#default_value' => t('Scratchy scratchpadae')
    );
  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Import'),
  );
  $form['#attributes'] = array('enctype' => 'multipart/form-data');

  return $form;
}

function taxonomy_import_parse($text, $vid, $import_format) {
  // Parse the data sent in the file, and shove it in to the Database.
  
  // Parse the file, creating the correct SQL as we go.
  // Each line will have an entry in the term_data table, and term_hierarchy table 
  // (roots having a parent of 0)
  
  // Let's first get the lowest value for "tid", upon which we will build all the
  // other values.
  $sql = "SELECT tid FROM {term_data} ORDER BY tid DESC LIMIT 1;";
  $result = db_query($sql);
  $sequence = array_pop(db_fetch_array($result));
  $sequence++;

  $term_data = "";
  $term_hierarchy = "";
  $synonym_data = "";
  $lines = preg_split("/[\n\r]+/", $text);
  
  // Values are:
  //  tid   vid   name         description weight
  // ($sequence, $vid, $parsedData, $parsedData, 0)
  
  // tid parent
  // $sequence $parent
  if($import_format==0){
    // Here we try and guess the import format, and set it accordingly.
    // Files are defined as below.  We only test the first 10 lines.
    // if first five chars = '<?xml' format is ubio
    // if all have the same number of tabs
    //   then they're 1 or 3
    //     if two or three tabs
    //       then 2
    //       else more 3
    //   else 2
    if (substr($lines[0],0,5)=="<?xml"){
      $import_format=4;
    }
    else {
      $numbers_of_tabs = array();
      for($i=0;$i<10;$i++){
        if (trim($lines[$i])==""){
          break;
        }
        $numbers_of_tabs[]=count(split("\t",$lines[$i]))-1;
      }
      // Check if they're all the same (add together, divide by number of them, if equal
      // to all of them, then they're the same.
      if (array_sum($numbers_of_tabs)/count($numbers_of_tabs)==$numbers_of_tabs[$i]){
        $import_format=2;
        if ((array_sum($numbers_of_tabs)/count($numbers_of_tabs))<4)
          $import_format=1;
      }
      if ($import_format!=2) {
        $import_format=3;
      }
    }
  }
  if($import_format==4){
    drupal_set_message('Imported using uBio XML format');
    taxonomy_import_ubio_import('','', $vid, $text);
  }
  else {
    if($import_format==1){
      // File is in the format:
      /*
  kingdom1    descriptionkingdom1 kingdom1syn1,kingdom1syn2
  phylum1 kingdom1  descriptionPhylum1  phylum1syn1,phylum1,syn2,phylum1syn3
  phylum2 kingdom1  descriptionPhylum2
  class1  phylum1 descriptionClass1 class1syn1
  order1  class1  descriptionOrder1 order1syn1
  class2  phylum1 descriptionClass2 */
      // Each line of the taxonomy constitues an entry into both of the tables.
      // Fill out the term_data first, filling out an array name=>parent_name
      // name=>number
      // which can then be converted into numbers.
      drupal_set_message('Imported using Parent/Child format');
      $parents = array();
      $term_id = array();
      foreach($lines as $line){
        if (trim($line)=="")
          break;
        $line_parts = split("\t",$line);
        // Remove '"' if at start or end of part
        for($i=0;$i<count($line_parts);$i++){
          $line_parts[$i] = trim($line_parts[$i]);
          if(substr($line_parts[$i],0,1)=='"')
            $line_parts[$i]=substr($line_parts[$i],1,strlen($line_parts[$i])-2);
        }
        
        $name = $line_parts[0];
        $parent = $line_parts[1];
        $description = (isset($line_parts[2])) ? $line_parts[2] : '';
        $synonyms = (isset($line_parts[3])) ? split(",",$line_parts[3]) : $synonyms=array();
      	if ($term_data !="")
      		$term_data .=",";
      	$term_data .= "(".$sequence.",".$vid.",'".addslashes($name)."','".addslashes($description)."',0)";
      	foreach($synonyms as $synonym){
      	  if ($synonym_data!="")
      	    $synonym_data.=",";
      	  $synonym_data .= '('.$sequence.',\''.addslashes(trim($synonym)).'\')';
      	}
      	$parents[$name]=$parent;
      	$term_id[$name]=$sequence;
      	$sequence++;
      }
      // We should now have all the term_data SQL created, and know the IDs for all
      // of the names, we can now create the hierachy SQL.
      $names = array_keys($parents);
      foreach ($names as $name){
        // Convert the parent name into an ID
        if ($term_hierarchy!="")
          $term_hierarchy .=",";
        $parent_id = $term_id[$parents[$name]];
        if ($parent_id=="")
          $parent_id="0";
        $term_hierarchy .= '('.$term_id[$name].','.$parent_id.')';
      }
    }
    elseif($import_format==2){
      drupal_set_message('Imported using tabbed hierarchy format');
      // File is in the format:
      /*
  kingdom1;descriptionKingdom1;snyKingdom1
    phylum1;descriptionPhylum1
      class1;description;class1
        order1;descriptionOrder1
      class2
        order2
        order3 */
      foreach ($lines as $line){
      	if (trim($line)=="")
      		break;
      	$line_parts = split(";",$line);
      	$name = $line_parts[0];
        $reference = (isset($line_parts[1])) ? $line_parts[1] : '';
        $synonyms = (isset($line_parts[2])) ? split(",",$line_parts[2]) : array();
      	// Count the number of tabs before the name.  There should be no tabs within the name, whilst
      	// all tabs after the name are removed.
      	$name = rtrim($name);
      	$count = count_chars($name, 1);
      	$rank = 0;
      	if (isset($count[ord("\t")]))
      		$rank = $count[ord("\t")];
      	
      	// Add the SQL for this item to the term_data stuff
      	if ($term_data !="")
      		$term_data .=",";
      	$term_data .= '('.$sequence.','.$vid.",'".addslashes(trim($name))."','".addslashes(trim($reference))."',0)";
      	foreach($synonyms as $synonym){
      	  if ($synonym_data!="")
      	    $synonym_data.=",";
      	  $synonym_data .= '('.$sequence.',\''.addslashes(trim($synonym)).'\')';
      	}
      	
      	// Set this as a parent item, wipe all parent items with numbers *LESS* than this (easiest way is to just
      	// copy over the ones below to a new array)
      	if ($rank>0){		
      		$temp_array=array();
      		for($i=0;$i<$rank;$i++){
      			if(isset($parents[$i]))
      				$temp_array[$i]=$parents[$i];
      		}
      		$parents=$temp_array;
      		if ($term_hierarchy !="")
      			$term_hierarchy .=",";
      		$term_hierarchy .= "(".$sequence.",".array_pop($temp_array).")";
      		$parents[$rank]=$sequence;
      	}
      	else{
      		$parents = array(0 => $sequence);
      		if ($term_hierarchy !="")
      			$term_hierarchy .=",";
      		$term_hierarchy .= "(".$sequence.",0)";
      	}
      	$sequence ++;
      }
    }
    elseif($import_format==3){
      drupal_set_message('Imported using full hierarchy format');
      // File is in the format:
      /*
  kingdom1  phylum1 class1  order1
  kingdom1  phylum1 class1  order2
  kingdom1  phylum1 class2  order3
  ...
      */
      $first_line = array_shift($lines);
      $first_line_parts = split("\t",$first_line);
      $number_of_ranks = 0;
      $line_parts_index = array();
      $i=0;
      foreach($first_line_parts as $part){        
        if(strtolower(trim($part))=='taxon'){
          $number_of_ranks++;
        } else {
          $line_parts_index[strtolower(trim($part))] = $i;
        }
        $i++;
      }
    	$names = array();
    	$hierarchy = array();
    	foreach ($lines as $line){
        if (trim($line)!=""){
          $line_parts = split("\t",$line);
          $taxon_parts = array();
          for($i=0;$i<$number_of_ranks;$i++){
            if(!in_array(trim($line_parts[$i]),$names) && trim($line_parts[$i]!="")){
              $name = trim($line_parts[$i]);
              $names[$sequence] = $name;
              $reference = $line_parts[$line_parts_index['description']];
    		      $synonyms = split(";",$line_parts[$line_parts_index['synonyms']]);
    		      if ($term_data !="")
    		        $term_data .=",";
              $term_data .= "(".$sequence.",".$vid.",'".addslashes($name)."','".addslashes(trim($reference))."',0)";
            	foreach($synonyms as $synonym){
            	  if ($synonym_data!="")
            	    $synonym_data.=",";
            	  $synonym_data .= '('.$sequence.',\''.addslashes(trim($synonym)).'\')';
            	}
    		      if ($term_hierarchy !="")
    		        $term_hierarchy .=",";
          		if ($i>0){
          			// Add to hierarchy
          			$parent = trim($line_parts[$i-1]);
          			$parent_id = array_search($parent, $names);
                $term_hierarchy .= '('.$sequence.','.$parent_id.')';
          		}
          		else {      			
                $term_hierarchy .= '('.$sequence.',0)';
          		}
              $sequence++;
            }
          }
        }
    	}
    }
    $term_hierarchy = "INSERT INTO {term_hierarchy} (tid, parent) VALUES ".$term_hierarchy;
    $term_data = "INSERT INTO {term_data} (tid, vid, name, description, weight) VALUES ".$term_data;
    if ($synonym_data !=""){
      $synonym_data = "INSERT INTO {term_synonym} (tid, name) VALUES ".$synonym_data;
    }
    db_query($term_data);
    db_query($term_hierarchy);
    if ($synonym_data !=""){
      db_query($synonym_data);
    }
    // Finally, check that the update totals exists, and do it!
    if (function_exists('leftandright_update_totals_variable')){
      leftandright_update_totals_variable();
    }
    drupal_goto('admin/content/taxonomy/'.$vid);
  }
}