<?php
// $Id$

/**
 * @file
 * XML Sitemap API documentation
 */

/**
 * @defgroup xmlsitemap XML Sitemap
 * @{
 * Notify search engines of site updates.
 *
 * XML Sitemap automatically creates a site map that conforms to the
 * @link http://sitemaps.org/ sitemaps.org @endlink specification. This helps
 * search engines keep their search results up to date. XML Sitemap is designed
 * to be extended by external modules. If you need capabilities which are not
 * provided by existing modules, you can add them to your own module.
 *
 * - hook_xmlsitemap_links() enables your module to add links to the site map.
 *   You can also use it to add site maps generated by other modules to the site
 *   map index.
 * - hook_xmlsitemap_engines() enables your module to add support for additional
 *   search engines.
 *
 * If your module's only purpose is to extend XML Sitemap, you should observe the following coding standards:
 *
 * - Start the name of your module with "XML Sitemap: ".
 * - Include "package = XML Sitemap" in your .info file.
 */

/**
 * @addtogroup hooks
 * @{
 */

/**
 * Define additional links to add to the site map.
 *
 * This hook allows modules to add additional links to the site map. Links may
 * be associated with nodes, terms, or users, as shown in the example.
 * @param $type:
 * If set, a string specifying the type of additional links to add. You can use
 * your own type or a type from one of the included modules:
 * - node:
 *   Links associated with nodes
 * - term:
 *   Links associated with terms
 * - user:
 *   Links associated with users
 * - xml:
 *   An XML site map (for including site maps from other modules)
 * You can define additional types by adding them to the switch statement.
 * @param $excludes:
 * Depends on the type of links being requested.
 * - For "node", an array of excluded node types
 * - For "term", an array of excluded vocabularies
 * - For "user", an array of included roles
 * @return
 * If $type is xml, return an XML site map. Otherwise, each link should be saved
 * to the xmlsitemap table. The xmlsitemap table contains the following columns:
 * - loc:
 *   The URL of the page
 * - lastmod:
 *   Timestamp of last modification
 * - changefreq:
 *   Number of seconds between changes
 * - priority:
 *   A number between 0 and 1 indicating the link's priority
 * Only the loc column is required.
 */
function hook_xmlsitemap_links($type = NULL, $excludes = array()) {
  switch ($GLOBALS['db_type']) {
    case 'mysql':
    case 'mysqli':
      $coalesce = 'COALESCE';
      $cast = 'CHAR';
      break;
    case 'pgsql':
      $coalesce = 'FIRST';
      $cast = 'VARCHAR';
      break;
  }
  switch ($type) {
    case 'node':
      break;
    case 'term':
      break;
    case 'user':
      // Load profiles.
      $result = db_query("
        SELECT u.uid, xu.last_changed, xu.previously_changed, xu.priority_override, SUM(xur.priority) as priority, $coalesce(ua.dst) AS alias
        FROM {users} u
        LEFT JOIN {users_roles} ur ON u.uid = ur.uid
        LEFT JOIN {xmlsitemap_user_role} xur ON ur.rid = xur.rid
        LEFT JOIN {xmlsitemap_user} xu ON u.uid = xu.uid
        LEFT JOIN {url_alias} ua ON ua.src = CONCAT('user/', CAST(u.uid AS $cast))
        WHERE (xu.priority_override IS NULL OR xu.priority_override >= 0) AND u.uid <> %d AND u.uid > 0 AND u.status <> 0
        GROUP BY u.uid, xu.last_changed, xu.previously_changed, xu.priority_override
        HAVING COUNT(xu.priority_override) > 0 OR (SUM(xur.priority) IS NULL AND %f <> -1 OR MIN(xur.priority) <> -1)
      ", _xmlsitemap_user_frontpage(), variable_get('xmlsitemap_user_default_priority', 0.5));
      // Create link array for each profile.
      while ($user = db_fetch_object($result)) {
        $age = time() - $user->last_changed;
        $interval = empty($user->previously_changed) ? 0 : $user->last_changed - $user->previously_changed;
        $link = array(
          'loc' => xmlsitemap_url("user/$user->uid", $user->alias, NULL, NULL, TRUE),
          'lastmod' => $user->last_changed,
          'changefreq' => max($age, $interval),
          'priority' => _xmlsitemap_user_priority($user),
        );
        db_query("INSERT INTO {xmlsitemap} (loc, lastmod, changefreq, priority) VALUES ('%s', %d, %d, %f)", $link);
      }
      // Add other user links to the xmlsitemap table.
      module_invoke_all('xmlsitemap_links', 'user');
      break;
    case 'xml':
      // Retrieve an XML site map.
      return example_sitemap();
    default:
      // Add arbitrary additional links.
      $result = db_query("
        SELECT xa.*, ua.dst AS alias FROM {xmlsitemap_additional} xa
        LEFT JOIN {url_alias} ua ON xa.pid = ua.pid
      ");
      while ($link = db_fetch_object($result)) {
        $age = time() - $link->last_changed;
        if (!empty($link->previously_changed)) {
          $interval = $link->last_changed - $link->previously_changed;
        }
        else {
          $interval = 0;
        }
        $link = array(
          'loc' => xmlsitemap_url($link->path, $link->alias, NULL, NULL, TRUE),
          'lastmod' => $link->last_changed,
          'changefreq' => max($age, $interval),
          'priority' => $link->priority,
        );
        db_query("INSERT INTO {xmlsitemap} (loc, lastmod, changefreq, priority) VALUES ('%s', %d, %d, %f)", $link);
      }
      break;
  }
}

/**
 * Define actions for search engines.
 * @param $op:
 * - form:
 *   Add search engine to form at admin/settings/xmlsitemap.
 * - ping:
 *   Submit site map to search engine.
 * - access:
 *   Log search engine access.
 * @param $type:
 * If $op is 'access', one of the following strings will indicate what was
 * downloaded:
 * - Site map:
 *   The site map was downloaded.
 * - Site map index
 *   The site map index was downloaded.
 * - Site map $chunk
 *   Chunk $chunk was downloaded.
 * @return
 * - form:
 *   Array of form elements for search engine settings
 * - ping:
 *   None
 * - access:
 *   Message string for access log
 */
function hook_xmlsitemap_engines($op, $type = NULL) {
  switch ($op) {
    case 'form':
      $form['google'] = array(
        '#type' => 'fieldset',
        '#title' => t('Google'),
        '#collapsible' => TRUE,
        '#collapsed' => TRUE,
      );
      $form['google']['xmlsitemap_engines_google_submit'] = array(
        '#type' => 'checkbox',
        '#title' => t('Submit site map to Google.'),
        '#default_value' => variable_get('xmlsitemap_engines_google_submit', TRUE),
      );
      $form['google']['xmlsitemap_engines_google_url'] = array(
        '#type' => 'textfield',
        '#title' => t('Submission URL'),
        '#default_value' => variable_get('xmlsitemap_engines_google_url', 'http://www.google.com/webmasters/tools/ping?sitemap='. xmlsitemap_url('sitemap.xml', drupal_lookup_path('alias', 'sitemap.xml') ? drupal_lookup_path('alias', 'sitemap.xml') : NULL, NULL, NULL, TRUE)),
        '#description' => t('The URL to submit the site map to.'),
      );
      $form['google']['xmlsitemap_engines_google_verify'] = array(
        '#type' => 'textfield',
        '#title' => t('Verification link'),
        '#default_value' => variable_get('xmlsitemap_engines_google_verify', ''),
        '#description' => t('In order to show statistics, Google will ask you to verify that you control this site by creating a file with a certain name. Enter that name here and the XML Sitemap module will create a path to that file name. This will only work if you have clean URLs enabled.'),
      );
      return $form;
    case 'ping':
      if (variable_get('xmlsitemap_engines_google_submit', TRUE)) {
        $result = drupal_http_request(variable_get('xmlsitemap_engines_google_url', 'http://www.google.com/webmasters/tools/ping?sitemap='. xmlsitemap_url('sitemap.xml', drupal_lookup_path('alias', 'sitemap.xml') ? drupal_lookup_path('alias', 'sitemap.xml') : NULL, NULL, NULL, TRUE)));
        if ($result->code == 200) {
          watchdog('xmlsitemap', t('Sitemap successfully submitted to Google.'));
        }
        else {
          watchdog('xmlsitemap', t('Error occurred submitting sitemap to Google: @code', array('@code' => $result->code)), WATCHDOG_ERROR);
        }
      }
      break;
    case 'access':
      if (strpos($_SERVER['HTTP_USER_AGENT'], 'Googlebot') !== FALSE) {
        return t('!sitemap downloaded by Google.', array('!sitemap' => $type));
      }
      break;
  }
}

/**
 * @} End of "addtogroup hooks".
 */

/**
 * @} End of "defgroup xmlsitemap".
 */

