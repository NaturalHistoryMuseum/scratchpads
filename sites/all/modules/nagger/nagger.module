<?php
// $Id$

/* TODO FormAPI image buttons are now supported.
   FormAPI now offers the 'image_button' element type, allowing developers to
   use icons or other custom images in place of traditional HTML submit buttons.

$form['my_image_button'] = array(
  '#type'         => 'image_button',
  '#title'        => t('My button'),
  '#return_value' => 'my_data',
  '#src'          => 'my/image/path.jpg',
); */

/* TODO node_access_rebuild($batch_mode = TRUE) / node_access_needs_rebuild()
   To avoid PHP timeouts when rebuilding content access permissions (which can
   critically leave the site's content half open), node_access_rebuild() now
   accepts a $batch_mode boolean parameter (defaults to FALSE), letting it
   operate in 'progressive' mode using the new D6 batch processing (progressbar
   processing, Ã  la update.php).
   See http://api.drupal.org/api/function/node_access_needs_rebuild/6. */

/* TODO Node access modules : simplified hook_enable / hook_disable / hook_node_access_records
   In D5, modules defining node access permissions via hook_node_grants /
   hook_node_access_records had to do a bit of hoop jumping : call
   node_access_rebuild() in their hook_enable / hook_disable, check they're not
   being disabled before actually returning their grants in hook_node_access_records()...
   This is not required in D6 anymore : the system ensures the node grants are
   rebuilt if needed when modules are enabled or disabled. Therefore, node access
   modules should *not* call node_access_rebuild themselves on enable/disable.  */

/* TODO New user_mail_tokens() method may be useful.
   user.module now provides a user_mail_tokens() function to return an array
   of the tokens available for the email notification messages it sends when
   accounts are created, activated, blocked, etc. Contributed modules that
   wish to make use of the same tokens for their own needs are encouraged
   to use this function. */

/* TODO
   There is a new hook_watchdog in core. This means that contributed modules
   can implement hook_watchdog to log Drupal events to custom destinations.
   Two core modules are included, dblog.module (formerly known as watchdog.module),
   and syslog.module. Other modules in contrib include an emaillog.module,
   included in the logging_alerts module. See syslog or emaillog for an
   example on how to implement hook_watchdog.
function example_watchdog($log = array()) {
  if ($log['severity'] == WATCHDOG_ALERT) {
    mysms_send($log['user']->uid,
      $log['type'],
      $log['message'],
      $log['variables'],
      $log['severity'],
      $log['referer'],
      $log['ip'],
      format_date($log['timestamp']));
  }
} */

/* TODO Implement the hook_theme registry. Combine all theme registry entries
   into one hook_theme function in each corresponding module file.
function nagger_theme() {
  return array(
  );
} */

/* TODO You may want to take advantage of new form-specific alter hooks.
   The hook_form_alter() is complemented by hook_form_$form-id_alter().
   Optionally, modules can implement form-specific alteration functions rather
   than a single hook_form_alter() with many conditional switch statements.
   This is optional, and is most useful for tidying the code of modules that
   alter many forms to customize a site's operations.
   The new function names are built using the following format:
   [your-module-name]_form_[$form_id]_alter. */

/**
 * Implementation of hook_node_grants
 */
function nagger_node_grants($account, $op){
  $grants['nagger'] = array_keys($account->roles);
  $grants['nagger_author'] = array($account->uid);
  return $grants;  
}

/**
 * Implementation of hook_node_access_records
 */
function nagger_node_access_records($node) {
  if (nagger_disabling()) {
    return;
  }
  $set_access = false;
  if(isset($node->nagger) && is_array($node->nagger)){
    foreach($node->nagger as $nag){
      if(in_array(1,$nag)){
        $set_access = true;
      }
    }
    if ($set_access){
      $role_ids = array_keys(user_roles());
      $grants = array();
      foreach($role_ids as $role_id){
        $grants[] = array(
          'realm' => 'nagger', 
          'gid' => $role_id,
          'grant_view' => $node->nagger[$role_id]['view'],
          'grant_update' => $node->nagger[$role_id]['update'], 
          'grant_delete' => $node->nagger[$role_id]['delete'],
          'priority' => 0,
        );
      }
      $grants[] = array(
        'realm' => 'nagger_author',
        'gid' => $node->uid,
        'grant_view' => true,
        'grant_update' => true,
        'grant_delete' => true,
        'priority' => 0
      );
      return $grants;
    }
  }
}

/**
 * Simple function to make sure we don't respond with grants when disabling
 * ourselves.
 */
function nagger_disabling($set = NULL) {
  static $disabling = false;
  if ($set !== NULL) {
    $disabling = $set;
  }
  return $disabling;
}

/**
 * Implementation of hook_disable
 */
function nagger_disable() {
  nagger_disabling(true);
  node_access_rebuild();
}

/**
 * Implementation of hook_form_alter
 */
function nagger_form_alter(&$form, &$form_state, $form_id) {  
  if ($form['#id'] == 'node-form') {
    global $user;
    /*if($form['#node']->uid != $user->uid){
      $form['og_nodeapi']['visible']['nagger'] = array(
        '#value' => '<p>'.t('Only the node author can change access permissions for this node').'</p>'
      );
      return;
    }*/
    drupal_add_css(drupal_get_path('module','nagger').'/nagger.css');
    $roles = user_roles();
    $roles_ids = array_keys($roles);
    $form['og_nodeapi']['visible']['nagger'] = array(
      '#weight'=>100,
      '#tree' => 1,
      '#type' => 'fieldset',
      '#title'=>t('Access by role'),
      '#description'=>t('Edit below, only if this node hasn\'t been added to a group. Leave the boxes unchecked to use the default access permissions')
    );
    $form['og_nodeapi']['visible']['nagger']['beforetable'] = array(
      '#value' => '<table class="nagger"><thead><tr><th>'.t('Role').'</th><th>'.t('View').'</th><th>'.t('Edit').'</th><th>'.t('Delete').'</th></tr></thead><tbody>'
    );
    // For each role, add three checkboxes
    foreach($roles_ids as $role_id){
      $form['og_nodeapi']['visible']['nagger'][$role_id]['view'] = array(
        '#type' => 'checkbox',
        '#default_value'=>isset($form['#node']->nagger[$role_id]['view'])?$form['#node']->nagger[$role_id]['view']:0,
        '#prefix' => '<tr><td>'.$roles[$role_id].'</td><td>',
        '#suffix' => '</td>'          
      );
      $form['og_nodeapi']['visible']['nagger'][$role_id]['update'] = array(
        '#type' => 'checkbox',
        '#default_value'=> isset($form['#node']->nagger[$role_id]['update'])?$form['#node']->nagger[$role_id]['update']:0,
        '#prefix' => '<td>',
        '#suffix' => '</td>'
      );
      $form['og_nodeapi']['visible']['nagger'][$role_id]['delete'] = array(
        '#type' => 'checkbox',
        '#default_value'=>isset($form['#node']->nagger[$role_id]['delete'])?$form['#node']->nagger[$role_id]['delete']:0,
        '#prefix' => '<td>',
        '#suffix' => '</td></tr>'
      );
    }
    $form['og_nodeapi']['visible']['nagger']['aftertable'] = array(
      '#value' => '</tbody></table>'
    );
    // Add validation so that a user CAN NOT add a node to a group, and restrict
    // its access - this is what this module does that content_access doesn't
    $form['#validate'][] = 'nagger_node_validate';    
  }
}

function nagger_node_validate($form, &$form_state){
  // If we've selected a group, check it for stuff.
  if (count($form_state['og_groups'])>0) {
    $error = false;
    foreach($form_state['nagger']['table'] as $role=>$value){
      if(in_array(1,$value)){
        form_set_error('og_groups', t('You\'ve selected a group, whilst also trying to restrict content access.  Either deselect the group, or uncheck all the access restriction boxes'));
        return;        
      }
    }
  }
}
/**
 * Implementation of hook_nodeapi
 */
function nagger_nodeapi(&$node, $op, $arg = 0) {
  switch ($op) {
    case 'load':
      $result = db_fetch_object(db_query('SELECT * FROM {nagger} WHERE nid = %d', $node->nid));
      $node->nagger = unserialize($result->settings);
      break;
    case 'delete':
      db_query('DELETE FROM {nagger} WHERE nid = %d', $node->nid);
      break;
    case 'update':
      db_query('DELETE FROM {nagger} WHERE nid = %d', $node->nid);      
    case 'insert':
      db_query("INSERT INTO {nagger} (nid, settings) VALUES (%d, '%s')", $node->nid, serialize($node->nagger));
      break;
  }
}