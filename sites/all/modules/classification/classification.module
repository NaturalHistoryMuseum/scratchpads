<?php
/* $Id:$ */

/** 
 * @file classification.module
 * This module makes it possible to import, edit and export names and classifications
 */

/**
 * Implementation of hook_help
 */
function classification_help($path, $arg) {
  switch($path) {
   case 'help#classification':
     $output = t('The Classification module provides the ability to import, edit, and export the classification you use to organize your content.');
     return $output;
  }
}

/**
 * Implementation of hook_perm
 */
function classification_perm() {
  return array(
    'access classification pages', 
    'create classification', 
    'import classification', 
    'edit classification', 
    'delete classification', 
    'export classification',
    'settings for classification'
  );
}

/**
 * Implementation of hook_init to add some js
 */
function classification_init() {
  $module_path = base_path().drupal_get_path('module', 'classification');
  drupal_add_js(array('classification_module_path' => $module_path), 'setting');
  drupal_add_js(array('classification_callback_base_url' => base_path().'classification'), 'setting');
  drupal_add_js(array('classification_callback_jstree' => base_path().'classification/js_tree/'), 'setting');
  drupal_add_js(array('classification_callback_jstree_viewer' => base_path().'classification/js_tree_viewer/'), 'setting');
  drupal_add_js(array('classification_callback_jstree_elements' => base_path().'classification/js_tree_elements/'), 'setting');
}

/**
 * Implementation of hook_theme()
 */
function classification_theme() {
  return array(
    'classification_manage' => array(
      'arguments' => array('form' => array()),
    ),
    'classification_tree' => array(
      'arguments' => array('element'), 
    ),
    'classification_tree_elements' => array( 
      'arguments' => array('element'), 
    ),
    'classification_import_message' => array( 
      'arguments' => array(), 
    ),
    'classification_logs_form' => array(
      'arguments' => array('form' => NULL),
    ),
  );
}

/**
 * Implementation of hook_nodeapi
 */
function classification_nodeapi($node, $op, $arg = 0) {
  //type is what kind of tagging for names is implemented: 1=single term autocomplete, 2=multiterm autocomplete; 3=tree selector
  $type = _classification_get_tag_type($node->type);

  switch ($op) {
	
    case 'load':
      if($type->select_option == 1 || $type->select_option == 2) {
	    $output['classification'] = classification_node_get_terms($node);
	    drupal_add_js(array('nid' => $node->nid), 'setting');
      }	  
      elseif ($type->select_option == 3) {
        $output['classification_tree'] = classification_node_tree_get_terms($node);
        $ancestry = array();
        foreach($output['classification_tree'] as $tid => $elements) {
           $current->tid = $tid;
           while ($parents = taxonomy_get_parents($current->tid)) {
             $current = array_shift($parents);
             $ancestry[] = 'n' . $current->tid;
           }
        }
        $ancestry = array_unique(array_reverse($ancestry));
        $ancestry = implode(",", $ancestry);
        drupal_add_js(array('nid' => $node->nid, 'ancestry' => $ancestry), 'setting');
      }
      else {
	    $output = '';
      }

      return $output;
      break;

    case 'validate':
      if(isset($node->classification) && empty($node->classification)) {
	    form_set_error('classification',t('A taxon name is required.'));
	    return;
      }
      if(isset($node->classification_tree) && empty($node->classification_tree)) {
	    form_set_error('classification_tree',t('At least one taxon name must be selected.'));
	    return;
      }
      if(isset($node->classification) && !empty($node->classification)) {
	     require_once("includes/classification_functions.class");
		 $names = new Names;
	     foreach ($node->classification['name_tags'] as $vid => $terms) {
		   $array = classification_explode_tags($terms);
		   foreach ($array as $name) {
		  	 $result = db_fetch_object(db_query("SELECT tid FROM {term_data} WHERE vid = %d AND name = '%s'", $vid, trim($name)));
		     if(!$result->tid){
		    	$bad_name[] = $names->italicized_form(trim($name));
		     }
		   }
		 }
		if($bad_name) {
		  form_set_error('classification',implode(', ',$bad_name)	. t(' does not exist in this site\'s classification'));
	      return;
		}
      }
      if(isset($node->classification_tree) && !empty($node->classification_tree)) {
	    $tags = $node->classification_tree['name_tags'];
        $ancestry = array();
        $checked = array();
        foreach($tags as $vid => $elements) {
	       foreach($elements as $tid => $state) {
		      $checked[] = $tid;
		      $current->tid = str_replace('n','',$tid);
		      while ($parents = taxonomy_get_parents($current->tid)) {
                $current = array_shift($parents);
                $ancestry[] = 'n' . $current->tid;
              }
	       }
        }
        $checked = implode(",", $checked);
        $ancestry = array_unique(array_reverse($ancestry));
        $ancestry = implode(",", $ancestry);
        drupal_add_js(array('ancestry' => $ancestry, 'checked' => $checked), 'setting');
      }
      break;

    case 'update':
    case 'insert':
      if(isset($node->classification) || isset($node->classification_tree)) {
	    if($type->select_option == 1 || $type->select_option == 2) {
           classification_node_save($node, $node->classification);
	    }
	    elseif ($type->select_option == 3) {
		   classification_tree_node_save($node, $node->classification_tree);
	    }
	    else {}
      }
      break;

    case 'delete':
      classification_node_delete($node);
      break;

    case 'delete revision':
      classification_node_delete_revision($node);
      break;

    case 'rss item':
      return classification_rss_item($node);

    case 'update index':
      return classification_node_update_index($node);
  }
}

/**
 * Implementation of hook_form_alter
 */
 
function classification_form_alter(&$form, $form_state, $form_id) {

  $vid = classification_get_vid('Taxa');
  
  /* First, we ensure the vocabulary called "Taxa" is not visible in the Drupal taxonomy listing because we don't want it to be deleted or modified */
  if($form_id == 'taxonomy_overview_vocabularies') {
    unset($form[$vid]);
  }
  /* Second, we remove "category" as a filtering option in Content management */
  elseif ($form_id == 'node_admin_content') {
    unset($form['filters']['status']['category']);
    unset($form['filters']['filter']['#options']['category']);
  }
  else {
  }

  if (isset($form['type']) && isset($form['#node']) && $form['type']['#value'] .'_node_form' == $form_id) {
    $node = $form['#node'];

    $tag_settings = _classification_get_tag_type($node->type);

    if($tag_settings) {
	  $weight = $tag_settings->weight;
      $required = $tag_settings->required == 1 ? TRUE : FALSE;
	  switch ($tag_settings->select_option) {
		case 1:
          if (isset($form_state['node_preview'])) {
	        $node->classification = classification_preview_terms($node);
            $typed_string = $node->classification['name_tags'][$vid];
          }
          else if (isset($_REQUEST['tid'])) {
			$terms = empty($node->nid) ? array() : classification_node_get_terms($node);
			$node->classification = $terms;
            $taxon = db_fetch_object(db_query("SELECT name FROM {term_data} WHERE tid = %d",$_REQUEST['tid']));
            $typed_string = $taxon->name;
          }
          else if (isset($form_state['rebuild'])) {
			$terms = empty($node->nid) ? array() : classification_node_get_terms($node);
			$node->classification = $terms;
	        $typed_string = $form_state['values']['classification']['name_tags'][$vid];
          }
          else {
			$terms = empty($node->nid) ? array() : classification_node_get_terms($node);
			$node->classification = $terms;
            $typed_string = classification_implode_tags($terms) . (array_key_exists('name_tags', $terms) ? $terms['name_tags'][$vid] : NULL);
          }
          $title = t('Taxon');
          $help = '';
          $autocomplete_path = 'classification/autocomplete_single/' . $vid;
          $ahah_path = 'classification/checkterm_single/' . $vid;
	        $form['classification'] = array(
	          '#type' => 'fieldset',
	          '#attributes' => array('style' => 'border:0px;margin:0px;padding:0px'),
	          '#weight' => $weight,
	        );

	        $form['classification']['classification_message'] = array(
	          '#type' => 'markup',
	          '#value' => '<div id="classification_message"></div>',
	        );

	        $form['classification']['name_tags'][$vid] = array(
	          '#type' => 'textfield',
	          '#title' => $title,
	          '#description' => $help,
	          '#parents' => array('classification','name_tags', $vid),
	          '#default_value' => $typed_string,
	          '#autocomplete_path' => $autocomplete_path,
	          '#maxlength' => 255,
	          '#required' => $required,
	          '#ahah' => array(
	     	      'event' => 'blur',
		          'path' => $ahah_path,
		          'wrapper' => 'classification_message',
		          'progress' => 'none',
	          ),
	        );
		  break;
		case 2:
          if (isset($form_state['node_preview'])) {
	        $node->classification = classification_preview_terms($node);
            $typed_string = $node->classification['name_tags'][$vid];
          }
          else if (isset($_REQUEST['tid'])) {
			$terms = empty($node->nid) ? array() : classification_node_get_terms($node);
			$node->classification = $terms;
            $taxon = db_fetch_object(db_query("SELECT name FROM {term_data} WHERE tid = %d",$_REQUEST['tid']));
            $typed_string = $taxon->name;
          }
          else if (isset($form_state['rebuild'])) {
			$terms = empty($node->nid) ? array() : classification_node_get_terms($node);
			$node->classification = $terms;
	        $typed_string = $form_state['values']['classification']['name_tags'][$vid];
          }
          else {
			$terms = empty($node->nid) ? array() : classification_node_get_terms($node);
			$node->classification = $terms;
            $typed_string = classification_implode_tags($terms) . (array_key_exists('name_tags', $terms) ? $terms['name_tags'][$vid] : NULL);
          }
          $title = t('Taxa');
          $help = t('A pipe-separated list of names for this content. Example: Pardosa moesta Banks, 1892 | Pardosa distincta (Blackwall, 1846)');
          $autocomplete_path = 'classification/autocomplete_multiple/' . $vid;
          $ahah_path = 'classification/checkterm_multiple/' . $vid;
	        $form['classification'] = array(
	          '#type' => 'fieldset',
	          '#attributes' => array('style' => 'border:0px;margin:0px;padding:0px'),
	          '#weight' => $weight,
	        );

	        $form['classification']['classification_message'] = array(
	          '#type' => 'markup',
	          '#value' => '<div id="classification_message"></div>',
	        );

	        $form['classification']['name_tags'][$vid] = array(
	          '#type' => 'textfield',
	          '#title' => $title,
	          '#description' => $help,
	          '#parents' => array('classification','name_tags', $vid),
	          '#default_value' => $typed_string,
	          '#autocomplete_path' => $autocomplete_path,
	          '#maxlength' => 255,
	          '#required' => $required,
	          '#ahah' => array(
	     	      'event' => 'blur',
		          'path' => $ahah_path,
		          'wrapper' => 'classification_message',
		          'progress' => 'none',
	          ),
	        );
		  break;
		case 3:
		  if(isset($form_state['rebuild'])) {
			 $tree = $form_state['values']['classification_tree']['name_tags'];
			 if(!empty($tree)) {
		       $node->classification_tree = classification_node_tree_rebuild_terms($tree);
		       $ancestry = array();
		       $checked = array();
	           foreach($node->classification_tree as $tid => $elements) {
		         $checked[] = 'n' . $tid;
	             $current->tid = $tid;
	             while ($parents = taxonomy_get_parents($current->tid)) {
	               $current = array_shift($parents);
	               $ancestry[] = 'n' . $current->tid;
	             }
	           }
	           $checked = implode(",", $checked);
	           $ancestry = array_unique(array_reverse($ancestry));
	           $ancestry = implode(",", $ancestry);
	           drupal_add_js(array('ancestry' => $ancestry, 'checked' => $checked), 'setting');
             }
		  }
		  else {
			 $terms = empty($node->nid) ? array() : classification_node_tree_get_terms($node);
			 $node->classification_tree = $terms;	
		  }
		  $form['classification_tree'] = array( 
		    '#type' => 'classification_tree', 
		  );
		  break;
	  }
    }

  }
} 

/**
 * Implementation of hook_block
 */
function classification_block($op = 'list', $delta = 0) {
  if (user_access('access content')) {
    if ($op == 'list') {
      $blocks[0]['info'] = t('Classification Navigator');
      return $blocks;
    }
    else {
      if ($op == 'view') {
        // Retrieve the tree
          $block['subject'] = t('Classification Navigator');
          $block['content'] = '<div id="classification_tree_block">';
          $vid = classification_get_vid('Taxa');
          $result = db_fetch_object(db_query("SELECT tid FROM {term_data} WHERE vid = %d LIMIT 1",$vid));
          $path = drupal_get_path('module', 'classification') . '/';
          if(!$result) {
              if(user_access('import classification')){
                $block['content'] .= l('<img src="' . $path . 'images/classification.png" style="float:left;margin-top:5px;" alt="Edit your classification" title="Edit your classifcation">','classification/import', array('html' => TRUE));
                $block['content'] .= '<div style="clear:both"></div><ul class="front_page_links" style="width:140px"><li class="classification">' . l(t('Add Classification'), 'classification/import') . '</li></ul>';
              }
              else {
                $block['content'] .= '<img src="' . $path . 'images/classification.png" style="float:left;margin-top:5px;" alt="Coming Soon!" title="Coming Soon!">';
                $block['content'] .= '<div style="clear:both"></div><p style="font-style:italic">Come back for a new classification</p>';
              }
          }
          else {
            drupal_add_css($path . 'css/classification.css');
            drupal_add_js($path .'jsTree/jquery.listen.js');
            drupal_add_js($path .'jsTree/css.js');
            drupal_add_js($path .'jsTree/tree_component.js');
            drupal_add_js($path .'js/classification_viewer.js');
            drupal_add_js(array('classification_vid' => array('vid' => $vid)), 'setting');
            
            $block['content'] .= '<div class="tree_wrapper_viewer">';
            $block['content'] .= '<div id="classification_tree_viewer"></div>';
            if(user_access('edit classification')){
              $block['content'] .= '<ul class="front_page_links" style="width:140px;"><li class="classification">' . l(t('Edit Classification'), 'classification/edit') . '</li></ul>';
            }
            $block['content'] .= '</div>';
          }
          $block['content'] .= '</div>';
      }
      return $block;
    }
  }
 }


/**
 * Helper function to convert terms after a preview.
 */
function classification_preview_terms($node) {
  $classification = array();
  if (isset($node->classification)) {
    foreach ($node->classification as $key => $term) {
      unset($node->classification[$key]);
      // A 'Multiple select' and a 'Free tagging' field returns an array.
      if (is_array($term)) {
        foreach ($term as $tid) {
          if ($key == 'name_tags') {
            // Free tagging; the values will be saved for later as strings
            // instead of objects to fill the form again.
            $classification['name_tags'] = $term;
          }
          else {
            $classification[$tid] = taxonomy_get_term($tid);
          }
        }
      }
      // A 'Single select' field returns the term id.
      elseif ($term) {
        $classification[$term] = taxonomy_get_term($term);
      }
    }
  }
  return $classification;
}

/**
 * Helper function to convert terms after a preview using the tree selector.
 */
function classification_preview_tree_terms($node) {
  $classification_tree = array();
  if (isset($node->classification_tree)) {
    foreach ($node->classification_tree as $key => $term) {
    }
  }
  return $classification_tree;
}

/**
 * Implode an array of tags into a string using a pipe as a delimiter.
 */
function classification_implode_tags($tags) {
  $typed_tags = array();
  foreach ($tags as $tag) {
      $typed_tags[] = $tag->name;
  }
  return implode(' | ', $typed_tags);
}

function classification_explode_tags($tags) {
  $regexp = '%(?:^|\|\ *)("(?>[^"]*)(?>""[^"]* )*"|(?: [^"\|]*))%x';
  preg_match_all($regexp, $tags, $matches);
  $typed_tags = array_unique($matches[1]);

  $tags = array();
  foreach ($typed_tags as $tag) {
    $tag = trim(preg_replace('/^"(.*)"$/', '\1', $tag));
    if ($tag != "") {
      $tags[] = $tag;
    }
  }

  return $tags;
}

/**
 * Find all taxon names associated with the given node.
 */
function classification_node_get_terms($node,$key = 'tid') {
  static $terms;

  if (!isset($terms[$node->vid][$key])) {
    $result = db_query(db_rewrite_sql('SELECT t.tid,t.vid,t.name FROM {classification_node} r INNER JOIN {term_data} t ON r.tid = t.tid INNER JOIN {vocabulary} v ON t.vid = v.vid WHERE r.vid = %d ORDER BY t.name', 't', 'tid'), $node->vid);
    $terms[$node->vid][$key] = array();
    while ($term = db_fetch_object($result)) {
      $terms[$node->vid][$key][$term->$key] = $term;
    }
  }
  
  return $terms[$node->vid][$key];
}

/**
 * Find all taxon names associated with the given node; used for the tree.
 */
function classification_node_tree_get_terms($node,$key = 'tid') {
  static $terms;

  if (!isset($terms[$node->vid][$key])) {
    $result = db_query(db_rewrite_sql('SELECT t.tid,t.vid FROM {classification_node} r INNER JOIN {term_data} t ON r.tid = t.tid INNER JOIN {vocabulary} v ON t.vid = v.vid WHERE r.vid = %d', 't', 'tid'), $node->vid);
    $terms[$node->vid][$key] = array();
    while ($term = db_fetch_object($result)) {
      $terms[$node->vid][$key][$term->$key] = $term;
    }
  }
  
  return $terms[$node->vid][$key];
}

/**
 * Rebuild the tree if the form is rebuilt prior to saving
 */
function classification_node_tree_rebuild_terms($tree) {
  static $terms;
  if(!$tree) {
    return;	
  }
  foreach($tree as $vid => $elements) {
	foreach($elements as $tid => $state) {
		$tid = str_replace("n","",$tid);
		$terms[$tid] = array(
			'tid' => $tid,
			'vid' => $vid
	    );
	}	
  }
  
  return $terms;
}

/**
 * Save name associations for a given node.
 */
function classification_node_save($node, $terms) {

  classification_node_delete_revision($node);

  // Free tagging vocabularies do not send their tids in the form,
  // so we'll detect them here and process them independently.
  if (isset($terms['name_tags'])) {
    $typed_input = $terms['name_tags'];
    unset($terms['name_tags']);

    foreach ($typed_input as $vid => $vid_value) {
      $typed_terms = classification_explode_tags($vid_value);

      $inserted = array();
      foreach ($typed_terms as $typed_term) {
        // See if the term exists in the chosen vocabulary

        $possibilities = taxonomy_get_term_by_name($typed_term);
        $typed_term_tid = NULL; // tid match, if any.
        foreach ($possibilities as $possibility) {
          if ($possibility->vid == $vid) {
            $typed_term_tid = $possibility->tid;
          }
        }

        // Defend against duplicate, differently cased tags
        if (!isset($inserted[$typed_term_tid])) {
          db_query('INSERT INTO {classification_node} (nid, vid, tid) VALUES (%d, %d, %d)', $node->nid, $node->vid, $typed_term_tid);
          $inserted[$typed_term_tid] = TRUE;
        }
      }
    }
  }

  if (is_array($terms)) {
    foreach ($terms as $term) {
      if (is_array($term)) {
        foreach ($term as $tid) {
          if ($tid) {
            db_query('INSERT INTO {classification_node} (nid, vid, tid) VALUES (%d, %d, %d)', $node->nid, $node->vid, $tid);
          }
        }
      }
      else if (is_object($term)) {
        db_query('INSERT INTO {classification_node} (nid, vid, tid) VALUES (%d, %d, %d)', $node->nid, $node->vid, $term->tid);
      }
      else if ($term) {
        db_query('INSERT INTO {classification_node} (nid, vid, tid) VALUES (%d, %d, %d)', $node->nid, $node->vid, $term);
      }
    }
  }
}

function classification_tree_node_save($node, $terms) {
	classification_node_delete_revision($node);
	if (isset($terms['name_tags'])) {
		$vid_terms = $terms['name_tags'];
		foreach ($vid_terms as $vid => $tid_arr) {
			foreach($tid_arr as $tid => $value) {
				$tid = str_replace("n","",$tid);
				db_query("INSERT INTO {classification_node} (nid,vid,tid) VALUES (%d,%d,%d)", $node->nid, $node->vid, $tid);
			}
		}
	}
}

/**
 * Remove associations of a node to its terms.
 */
function classification_node_delete($node) {
  db_query('DELETE FROM {classification_node} WHERE nid = %d', $node->nid);
}

/**
 * Remove associations of a node to its terms.
 */
function classification_node_delete_revision($node) {
  $vid = classification_get_vid('Taxa');
  db_query('DELETE FROM {classification_node} WHERE vid = %d', $node->vid);
}

function classification_menu() {

/**
 * Menu items
 */
 
    $items['classification'] = array(
      'title' => t('Classification'),
      'description' => t('Manage your classification(s).'),
      'type' => MENU_NORMAL_ITEM,
      'page callback' => 'classification_menu_block_page',
      'access arguments' => array('access classification pages'),
      'file' => 'includes/classification.default.inc',
      'weight' => -5,
    );

    $items['classification/import'] = array(
      'title' => t('Add / Import'),
      'description' => t('Import names into your site\'s classification or into any temporary classification if present. These functions are typically used once; thereafter, the editor may be used to add names and manage your classification.'),
      'page callback' => 'drupal_get_form',
      'page arguments' => array('classification_import_form'),
      'access arguments' => array('import classification'),
      'type' => MENU_LOCAL_TASK,
      'weight' => -1,
      'file' => 'includes/classification.import.inc',
    );

    $items['classification/edit'] = array(
       'title' => t('Edit'),
       'description' => t('Edit your site\'s classification, assign taxonomic ranks, maintain name relationships, <em>etc.</em>.'),
       'page callback' => 'drupal_get_form',
       'page arguments' => array('classification_edit_form',2),
       'access arguments' => array('edit classification'),
       'type' => MENU_LOCAL_TASK,
       'weight' => 0,
       'file' => 'includes/classification.edit.inc',
    );
    
    $items['classification/export'] = array(
       'title' => t('Export'),
       'description' => t('Export your classification for use elsewhere.'),
       'page callback' => 'drupal_get_form',
       'page arguments' => array('classification_export_form'),
       'access arguments' => array('export classification'),
       'type' => MENU_LOCAL_TASK,
       'weight' => 1,
       'file' => 'includes/classification.export.inc',
    );

    $items['classification/settings'] = array(
      'title' => t('Content Settings'),
      'description' => t('Advanced settings for taxonomic names used on content submission forms.'),
      'page callback' => 'drupal_get_form',
      'page arguments' => array('classification_administration_form'),
      'access arguments' => array('settings for classification'),
      'type' => MENU_LOCAL_TASK,
      'weight' => 2,
      'file' => 'includes/classification.settings.inc',
    );

    $items['classification/manage'] = array(
      'title' => t('Alternate Classifications'),
      'description' => t('Manage temporary classifications that may be used to drag & drop names into your site\'s classification.'),
      'page callback' => 'drupal_get_form',
      'page arguments' => array('classification_manage'),
      'access arguments' => array('create classification'),
      'type' => MENU_LOCAL_TASK,
      'weight' => 3,
      'file' => 'includes/classification.manage.inc',
    );

    $items['classification/logs'] = array(
      'title' => t('Activity Logs'),
      'description' => t('View the activity in the classification editor performed by users with appropriate permissions.'),
      'page callback' => 'drupal_get_form',
      'page arguments' => array('classification_logs_form'),
      'access arguments' => array('access classification pages'),
      'type' => MENU_LOCAL_TASK,
      'weight' => 4,
      'file' => 'includes/classification.logs.inc',
    );

    $items['classification/logs/rss'] = array(
      'page callback' => 'classificataion_logs_rss',
      'access arguments' => array('access content'),
      'type' => MENU_CALLBACK,
      'file' => 'includes/classification.logs.inc',
    );
  
    $items['classification/help'] = array(
      'title' => t('Help'),
      'description' => t('Instructions to help you work with the Classification functions.'),
      'page callback' => 'classification_help_pages',
      'access arguments' => array('access classification pages'),
      'type' => MENU_LOCAL_TASK,
      'weight' => 5,
      'file' => 'includes/classification.help.inc',
    );
    
/**
 * Callbacks
 */
    $items['classification/autocomplete_single'] = array(
      'title' => t('Classification Autocomplete'),
      'page callback' => 'classification_autocomplete_single',
      'type' => MENU_CALLBACK,
      'access arguments' => array('access content'),
      'file' => 'includes/classification.default.inc',
    );
 
     $items['classification/autocomplete_multiple'] = array(
      'title' => t('Classification Autocomplete for Multiple Name Tags'),
      'page callback' => 'classification_autocomplete_multiple',
      'type' => MENU_CALLBACK,
      'access arguments' => array('access content'),
      'file' => 'includes/classification.default.inc',
    );
    
    $items['classification/checkterm_single'] = array(
      'title' => t('Classification Term Check'),
      'page callback' => 'classification_checkterm_single',
      'type' => MENU_CALLBACK,
      'access arguments' => array('access content'),
      'file' => 'includes/classification.default.inc',
    );

    $items['classification/checkterm_multiple'] = array(
      'title' => t('Classification Term Check'),
      'page callback' => 'classification_checkterm_multiple',
      'type' => MENU_CALLBACK,
      'access arguments' => array('access content'),
      'file' => 'includes/classification.default.inc',
    );
    
    $items['classification/import_classification'] = array(
      'title' => t('Import Classification'),
      'page callback' => 'classification_import_classification',
      'type' => MENU_CALLBACK,
      'access arguments' => array('import classification'),
      'file' => 'includes/classification.import.inc',
    );

    $items['classification/import_status'] = array(
      'title' => t('Import Status'),
      'page callback' => 'classification_import_status',
      'type' => MENU_CALLBACK,
      'access arguments' => array('import classification'),
      'file' => 'includes/classification.import.inc',
    );

    $items['classification/import_message'] = array(
      'title' => t('Import Message'),
      'page callback' => 'theme',
      'page arguments' => array('classification_import_message'),
      'type' => MENU_CALLBACK,
      'access arguments' => array('import classification'),
      'file' => 'includes/classification.import.inc',
    );

    $items['classification/delete_classification'] = array(
      'title' => t('Delete Classfication'),
      'page callback' => 'classification_delete_classification',
      'type' => MENU_CALLBACK,
      'access arguments' => array('delete classification'),
      'file' => 'includes/classification.manage.inc',
    );
    
    $items['classification/import/search'] = array(
      'title' => t('Search'),
      'page callback' => 'classification_import_search',
      'type' => MENU_CALLBACK,
      'access arguments' => array('import classification'),
      'file' => 'includes/classification.import.inc',
    );

    $items['classification/autocomplete'] = array(
      'title' => 'Autocomplete for rerooting tree',
      'page callback' => 'classification_autocomplete',
      'access arguments' => array('edit classification'),
      'type' => MENU_CALLBACK,
      'file' => 'includes/classification.edit.inc',
    );

    $items['classification/checkterm'] = array(
      'title' => 'Look for tid along with autocomplete',
      'page callback' => 'classification_checkterm',
      'access arguments' => array('edit classification'),
      'type' => MENU_CALLBACK,
      'file' => 'includes/classification.edit.inc',
    );
    
     $items['classification/js_tree'] = array(
      'title' => t('Classification tree callback'),
      'page callback' => 'classification_js_tree',
      'access arguments' => array('access content'),
      'type' => MENU_CALLBACK,
      'file' => 'includes/classification.edit.inc',
    );

     $items['classification/js_tree2'] = array(
      'title' => t('Classification tree callback'),
      'page callback' => 'classification_js_tree_alternate',
      'access arguments' => array('access content'),
      'type' => MENU_CALLBACK,
      'file' => 'includes/classification.edit.inc',
    );

     $items['classification/js_tree_viewer'] = array(
      'title' => t('Classification tree callback'),
      'page callback' => 'classification_js_tree',
      'access arguments' => array('access content'),
      'type' => MENU_CALLBACK,
      'file' => 'includes/classification.viewer.inc',
    );

    $items['classification/js_tree_elements'] = array(
      'title' => t('Classification tree callback'),
      'page callback' => 'classification_js_tree',
      'access arguments' => array('access content'),
      'type' => MENU_CALLBACK,
      'file' => 'includes/classification.elements.inc',
    );

    $items['classification/js_tree_checked'] = array(
      'title' => t('Classification tree callback'),
      'page callback' => 'classification_js_tree_checked',
      'access arguments' => array('access content'),
      'type' => MENU_CALLBACK,
      'file' => 'includes/classification.elements.inc',
     );

     $items['classification/get_metadata'] = array(
      'title' => t('Classification Form Editor'),
      'page callback' => 'classification_get_metadata',
      'access arguments' => array('edit classification'),
      'type' => MENU_CALLBACK,
      'file' => 'includes/classification.edit.inc',
    );

     $items['classification/get_parent'] = array(
      'title' => t('Classification Parent Search'),
      'page callback' => 'classification_get_parent',
      'access arguments' => array('edit classification'),
      'type' => MENU_CALLBACK,
      'file' => 'includes/classification.edit.inc',
    );

    $items['classification/get_parents'] = array(
      'title' => t('Classification Parents List'),
      'page callback' => 'classification_get_parents',
      'access arguments' => array('edit classification'),
      'type' => MENU_CALLBACK,
      'file' => 'includes/classification.edit.inc',
     );

     $items['classification/get_synonyms'] = array(
      'title' => t('Classification Synomnym Search'),
      'page callback' => 'classification_get_synonyms_json',
      'access arguments' => array('access content'),
      'type' => MENU_CALLBACK,
      'file' => 'includes/classification.edit.inc',
    );
       
     $items['classification/update_metadata'] = array(
      'title' => t('Classification Form Editor'),
      'page callback' => 'classification_update_metadata',
      'access arguments' => array('edit classification'),
      'type' => MENU_CALLBACK,
      'file' => 'includes/classification.edit.inc',
    );

     $items['classification/update_settings'] = array(
      'title' => t('Classification Settings Editor'),
      'page callback' => 'classification_update_settings',
      'access arguments' => array('edit classification'),
      'type' => MENU_CALLBACK,
      'file' => 'includes/classification.edit.inc',
    );
    
    $items['classification/edit_name'] = array(
       'title' => t('Edit'),
       'page callback' => 'classification_edit_name',
       'access arguments' => array('edit classification'),
       'type' => MENU_CALLBACK,
       'file' => 'includes/classification.edit.inc',
    );
    
    $items['classification/add_name'] = array(
       'title' => t('Add'),
       'page callback' => 'classification_add_name',
       'access arguments' => array('edit classification'),
       'type' => MENU_CALLBACK,
       'file' => 'includes/classification.edit.inc',
    );

    $items['classification/delete_name'] = array(
       'title' => t('Delete'),
       'page callback' => 'classification_delete_name',
       'access arguments' => array('edit classification'),
       'type' => MENU_CALLBACK,
       'file' => 'includes/classification.edit.inc',
    );

    $items['classification/move_name'] = array(
       'title' => t('Drag and Drop'),
       'page callback' => 'classification_move_name',
       'access arguments' => array('edit classification'),
       'type' => MENU_CALLBACK,
       'file' => 'includes/classification.edit.inc',
    );

    $items['classification/copy_name_alternate'] = array(
       'title' => t('Drag and Drop'),
       'page callback' => 'classification_copy_name_alternate',
       'access arguments' => array('edit classification'),
       'type' => MENU_CALLBACK,
       'file' => 'includes/classification.edit.inc',
    );
    
  return $items;
}

/**
 * Get the necessary $vid for various forms
 */
function classification_get_vid($name) {
  $voc = db_fetch_object(db_query(db_rewrite_sql("SELECT vid FROM {vocabulary} WHERE name = '%s'"), $name));
  return $voc->vid;
}

/**
 * Used to check name of vocabulary for use in canonical display
 * And elect not to perform canonical regex on terms
 */
function classification_get_vocabulary($vid) {
  $voc_name = db_fetch_object(db_query(db_rewrite_sql("SELECT name FROM {vocabulary} WHERE vid = %d"), $vid));
  return $voc_name->name;
}

/******************************************
 * CLASSIFICATION FORM ELEMENT DEFINITION
 * 
 * how to use:
 *
 * $css_file = drupal_get_path('module', 'classification_demo') . '/classification_demo.css';
 *
 * $form['name'] = array( 
 *   '#type' => 'classification_tree',
 *   '#css_file' => $css_file,
 * );
 * 
 * Optional parameters:
 *   #voc_name: specify the vocabulary name to use for the tree
 ******************************************/

/**
 * Implementation of hook_elements
 */
function classification_elements() {
  $type['classification_tree'] = array( 
    '#input' => TRUE, 
    '#process' => array('classification_tree_process_elements'), 
    '#tree' => TRUE,
  );

  return $type;
}

/**
 * Processes the classification form element
 * 
 * @param $element
 * @return the classification element
 */
function classification_tree_process_elements($element) {
  
  static $classification_tree;
  $classification_tree[] = $element['#type'];

  $module_path = drupal_get_path('module', 'classification') .'/';
  drupal_add_css($module_path . 'css/classification_element.css');
  drupal_add_js($module_path .'js/jquery.curvycorners.js');  
  drupal_add_js($module_path .'jsTree/jquery.listen.js');
  drupal_add_js($module_path .'jsTree/css.js');
  drupal_add_js($module_path .'jsTree/tree_component_element.js');
  drupal_add_js($module_path .'js/classification_element.js');
  
  $element['#voc_name'] = isset($element['#voc_name']) ? $element['#voc_name'] : 'Taxa';
  $element['#css_file'] = isset($element['#css_file']) ? drupal_add_css($element['#css_file']) : drupal_add_css($module_path .'css/classification_element.css');
  $element['#tree'] = TRUE;
  $element['#prefix'] = '<div class="classification_tree_panel"><div class="classification_tree_wrapper"><div class="classification_tree_div"><div class="fc_tree"><div class="c"><div class="inner"><h3 class="h">' . t('Classification') . '</h3><ul class="front_page_links_expand"><li class="expand"><a href="#" onclick="javascript:return false">&nbsp;</a></li><li class="contract"><a href="#" onclick="javascript:return false">&nbsp;</a></li></ul>';
  $element['#suffix'] = '</div></div></div></div></div></div>';

  $vid = classification_get_vid($element['#voc_name']);

  if($_GET['tid'] && count($classification_tree)==1) {
    $current->tid = $_GET['tid'];
    while ($parents = taxonomy_get_parents($current->tid)) {
       $current = array_shift($parents);
       $ancestry[] = 'n' . $current->tid;
    }
    $ancestry = array_unique(array_reverse($ancestry));
    $ancestry = implode(",", $ancestry);
	$checked = 'n' . $_GET['tid'];
	drupal_add_js(array('ancestry' => $ancestry, 'checked' => $checked), 'setting');
   }

  if(count($classification_tree)==1) {
	drupal_add_js(array('classification_vid' => array('vid' => $vid)), 'setting');
  }
  
  return $element;
}

/**
 * theme function for tree
 *
 * @param $element
 * @return html output
 */
function theme_classification_tree(&$element) {
  $tree = theme('classification_tree_elements', $element['#elements']);
  return $tree;
}

function theme_classification_tree_elements($element) {
  $output = '<div class="tree_wrapper_viewer">';
  $output .= '<div id="classification_tree_viewer"></div>';
  if(user_access('edit classification')){
    $output .= '<ul class="front_page_links" style="width:140px;"><li class="classification">' . l(t('Edit Classification'), 'classification/edit') . '</li></ul>';
  }
  $output .= '</div>';
  return $output;
}

/**
 * Provides category information for RSS feeds.
 */
function classification_rss_item($node) {
  $output = array();
  foreach ($node->classification as $term) {
    $output[] = array('key'   => 'category',
                      'value' => check_plain($term->name),
                      'attributes' => array('domain' => url('taxonomy/term/'. $term->tid, array('absolute' => TRUE))));
  }
  return $output;
}

/**
 * Produce an array of tid and rank given a tid
 */
function classification_get_rank($tid) {
  $result = db_fetch_object(db_query("SELECT value FROM {taxonomy_enhancer_value_text} WHERE fid = 'field_rank' AND tid = %d",$tid));
  $output[$tid] = array('tid' => $tid,
                        'rank' => check_plain($result->value),
                  );
  return $output;
}

/**
 * Produce an array of all available ranks either as only those allowed (TRUE) or based on all ranks in {taxonomy_enhancer_value_text}
 * NOTE: When $allowed is set, it is assumed that the ranks are produced in a Linnaen arrangement
 */
function classification_get_ranks($allowed = TRUE) {
  $output = '';
  if($allowed) {
    $result = db_fetch_object(db_query("SELECT settings FROM {taxonomy_enhancer_fields} WHERE fid = 'field_rank'"));
    $settings = drupal_unpack($result,'settings');
    $values = $settings->allowed_values;
    foreach ($values as $value) {
       $output[] = $value;
    }
  }
  else {
    $result = db_query("SELECT DISTINCT value FROM {taxonomy_enhancer_value_text} WHERE fid = 'field_rank' AND length(value)>0");
    while ($object = db_fetch_object($result)) {
       $output[] = check_plain($object->value);
    }
  }
  return $output;
}

/**
 * Produce an array of child vernaculars with their languages given a parent tid
 */
function classification_get_vernaculars($tid) {
  $output = '';
  $vid = classification_get_vid('Taxa');
  
  $result = db_query(db_rewrite_sql("
     SELECT 
        td.tid as tid, 
        td.name as name,
        tevt.value as language
     FROM
        {term_data} td 
     JOIN 
        {taxonomy_enhancer_value_text} tevt ON (tevt.tid=td.tid) 
     JOIN 
        {term_hierarchy} th on (td.tid=th.tid) 
     LEFT JOIN 
      	({term_relation} tr 
     	    JOIN {term_relation_has_type} trht ON (tr.trid=trht.trid) 
     	    JOIN {term_relation_types} trt ON (trht.rtid=trt.rtid)
     	  ) ON td.tid=tr.tid1 
	   WHERE 
	      td.vid = %d AND th.parent = %d AND trt.rtid = 9 
	   ORDER BY 
	      td.name"),$vid,$tid);
	
  while ($object = db_fetch_object($result)) {
     $tid = $object->tid;
     $name = $object->name;
     $language = $object->language;
     $output[] = array('tid' => $tid, 'name' => check_plain($name) , 'language' => $language);
  }
	
  return $output;
}

/**
 * Produce an array of child names other than vernaculars given a parent tid
 */
function classification_get_synonyms($tid) {
  $output = '';
  $vid = classification_get_vid('Taxa');
  $result = db_query(db_rewrite_sql("
     SELECT 
        td.tid as tid, 
        td.name as name,
        trt.name as relation 
     FROM
        {term_data} td 
     JOIN 
        {term_hierarchy} th on (td.tid=th.tid) 
     LEFT JOIN 
      	({term_relation} tr 
     	    JOIN {term_relation_has_type} trht ON (tr.trid=trht.trid) 
     	    JOIN {term_relation_types} trt ON (trht.rtid=trt.rtid)
     	  ) ON td.tid=tr.tid1 
	   WHERE 
	      td.vid = %d AND th.parent = %d AND trt.rtid <> 9  
	   ORDER BY 
	      td.name"),$vid,$tid);
	      
  while ($object = db_fetch_object($result)) {
     $tid = $object->tid;
     $name = $object->name;
     $relation = $object->relation;
     $output[] = array('tid' => $tid, 'name' => check_plain($name) , 'relation' => $relation);
  }
  return $output;
}



/******************************************************
  Public Functions to Duplicate Taxonomy and node search Functionality
******************************************************/

/**
 * Count the number of published nodes classified by a taxon name.
 *
 * @param $tid
 *   The term's ID
 *
 * @param $type
 *   The $node->type. If given, classification_term_count_nodes only counts
 *   nodes of $type that are classified with the term $tid.
 *
 * @return int
 *   An integer representing a number of nodes.
 *   Results are statically cached.
 */
function classification_term_count_nodes($tid, $type = 0) {
  static $count;

  if (!isset($count[$type])) {
    // $type == 0 always evaluates TRUE if $type is a string
    if (is_numeric($type)) {
      $result = db_query(db_rewrite_sql('SELECT t.tid, COUNT(n.nid) AS c FROM {classification_node} t INNER JOIN {node} n ON t.vid = n.vid WHERE n.status = 1 GROUP BY t.tid'));
    }
    else {
      $result = db_query(db_rewrite_sql("SELECT t.tid, COUNT(n.nid) AS c FROM {classification_node} t INNER JOIN {node} n ON t.vid = n.vid WHERE n.status = 1 AND n.type = '%s' GROUP BY t.tid"), $type);
    }
    $count[$type] = array();
    while ($term = db_fetch_object($result)) {
      $count[$type][$term->tid] = $term->c;
    }
  }
  $children_count = 0;
  foreach (_classification_term_children($tid) as $c) {
    $children_count += classification_term_count_nodes($c, $type);
  }
  return $children_count + (isset($count[$type][$tid]) ? $count[$type][$tid] : 0);
}

/**
 * Helper for classification_term_count_nodes(). Used to find out
 * which terms are children of a parent term.
 *
 * @param $tid
 *   The parent term's ID
 *
 * @return array
 *   An array of term IDs representing the children of $tid.
 *   Results are statically cached.
 *
 */
function _classification_term_children($tid) {
  static $children;

  if (!isset($children)) {
    $result = db_query('SELECT tid, parent FROM {term_hierarchy}');
    while ($term = db_fetch_object($result)) {
      $children[$term->parent][] = $term->tid;
    }
  }
  return isset($children[$tid]) ? $children[$tid] : array();
}

/**
 * Finds all nodes that match selected taxonomy conditions.
 *
 * @param $tids
 *   An array of term IDs to match.
 * @param $operator
 *   How to interpret multiple IDs in the array. Can be "or" or "and".
 * @param $depth
 *   How many levels deep to traverse the taxonomy tree. Can be a nonnegative
 *   integer or "all".
 * @param $pager
 *   Whether the nodes are to be used with a pager (the case on most Drupal
 *   pages) or not (in an XML feed, for example).
 * @param $order
 *   The order clause for the query that retrieve the nodes.
 * @return
 *   A resource identifier pointing to the query results.
 */
function classification_select_nodes($tids = array(), $operator = 'or', $depth = 0, $pager = TRUE, $order = 'n.sticky DESC, n.created DESC') {
  if (count($tids) > 0) {
    // For each term ID, generate an array of descendant term IDs to the right depth.
    $descendant_tids = array();
    if ($depth === 'all') {
      $depth = NULL;
    }
    foreach ($tids as $index => $tid) {
      $term = taxonomy_get_term($tid);
      $tree = taxonomy_get_tree($term->vid, $tid, -1, $depth);
      $descendant_tids[] = array_merge(array($tid), array_map('_taxonomy_get_tid_from_term', $tree));
    }

    if ($operator == 'or') {
      $args = call_user_func_array('array_merge', $descendant_tids);
      $placeholders = db_placeholders($args, 'int');
      $sql = 'SELECT DISTINCT(n.nid), n.sticky, n.title, n.created FROM {node} n INNER JOIN {classification_node} cn ON n.vid = cn.vid WHERE cn.tid IN ('. $placeholders .') AND n.status = 1 ORDER BY '. $order;
      $sql_count = 'SELECT COUNT(DISTINCT(n.nid)) FROM {node} n INNER JOIN {classification_node} cn ON n.vid = cn.vid WHERE cn.tid IN ('. $placeholders .') AND n.status = 1';
    }
    else {
      $joins = '';
      $wheres = '';
      $args = array();
      foreach ($descendant_tids as $index => $tids) {
        $joins .= ' INNER JOIN {classification_node} cn'. $index .' ON n.vid = cn'. $index .'.vid';
        $wheres .= ' AND cn'. $index .'.tid IN ('. db_placeholders($tids, 'int') .')';
        $args = array_merge($args, $tids);
      }
      $sql = 'SELECT DISTINCT(n.nid), n.sticky, n.title, n.created FROM {node} n '. $joins .' WHERE n.status = 1 '. $wheres .' ORDER BY '. $order;
      $sql_count = 'SELECT COUNT(DISTINCT(n.nid)) FROM {node} n '. $joins .' WHERE n.status = 1 '. $wheres;
    }
    $sql = db_rewrite_sql($sql);
    $sql_count = db_rewrite_sql($sql_count);
    if ($pager) {
      $result = pager_query($sql, variable_get('default_nodes_main', 10), 0, $sql_count, $args);
    }
    else {
      $result = db_query_range($sql, $args, 0, variable_get('feed_default_items', 10));
    }
  }

  return $result;
}

/**
 * Return counts and kinds of media nodes
 */
function classification_term_count_media($tid) {
  $output = array();
  $result = db_query("
  SELECT 
    n.nid, n.type, COUNT(*) AS count 
  FROM {node} n 
  JOIN {classification_node} tn ON (n.nid=tn.nid) 
  WHERE tn.tid = %d 
  GROUP BY type",$tid);
  
  $media = array();
  while ($row = db_fetch_object($result)) {
    $output[$row->type] = $row->count;
  }
  
  return $output;
}
 
/**
 * Implementation of hook_nodeapi('update_index').
 */
function classification_node_update_index(&$node) {
  $output = array();
  foreach ($node->classification as $term) {
    $output[] = $term->name;
  }
  if (count($output)) {
    return '<strong>('. implode(' | ', $output) .')</strong>';
  }
}

function _classification_update_lists($fid,$title,$list) {
  $vid = classification_get_vid('Taxa');
  $list_arr = explode(" ",$list);
  foreach ($list_arr as $item) {
	$opt[] = $item;
  }
  $field = array(
    'vid' => $vid,
    'fid' => 'field_' . $fid,
    'title' => $title,
    'module' => 'classification',
    'type' => 'options',
    'weight' => 0,
    'settings' => array(),
  );
  $field['settings']['allowed_values'] = $opt;
  $field['settings']['options_type'] = 'select';
  
  db_query("INSERT INTO {taxonomy_enhancer_fields} (vid,fid,title,module,type,weight,settings) VALUES (%d,'%s','%s','%s','%s',%d,'%s')",$field['vid'],$field['fid'],$field['title'],$field['module'],$field['type'],$field['weight'],serialize($field['settings']));

}

function _classification_get_tag_type($node_type) {
	$type = db_fetch_object(db_query("SELECT type,select_option,weight,required FROM {classification_node_types} WHERE type = '%s'", $node_type));
	return $type;
}