<?php
// $Id$
// $HeadURL$

/** 
 * @file autotag.module
 * 
 * Automatically tags nodes with terms depending on the content of textfields.
 * Textfields to ignore can be set on the modules settings page, along with the 
 * number of nodes to search on cron.  Once all nodes have been search by cron,
 * this module shouldn't do anything on a cron run.
 */

/**
 * Implementation of hook_nodeapi
 */
function autotag_nodeapi(&$node, $op, $a3 = NULL, $a4 = NULL){
  module_load_include('functions.inc','autotag');
  _autotag_nodeapi($node, $op, $a3, $a4);
}

/**
 * Implementation of hook_menu
 * 
 * Needed only for the module's settings page, and the autocomplete function
 */
function autotag_menu(){
  return array(
    'autotag/autocomplete' => array(
      'title' => 'Autocomplete autotag thingumy',
      'page callback' => 'autotag_autocomplete',
      'access arguments' => array('access content'),// Hmmm, not ideal!
      'type' => MENU_CALLBACK,
      'file' => 'autotag.autocomplete.inc'
    ),
    'admin/settings/autotag' => array(
      'title' => 'Autotag settings',
      'description' => 'Change the default autotag settings.',
      'page callback' => 'drupal_get_form',
      'page arguments' => array('autotag_admin_settings'),
      'access arguments' => array('administer site configuration'),
      'file' => 'autotag.settings.inc'
    )
  );
}

/**
 * Simply save what was entered in the checkbox
 */
function autotag_submit_vocabulary_form($form, $form_values){
  // Merge the array with what is already there.
  $disable_vids = variable_get('autotag_disable_vids', array());
  $disable_vids[$form_values['vid']] = $form_values['values']['disableautotag'];
  variable_set('autotag_disable_vids', $disable_vids);
}

/**
 * Receive the form after the first page, nothing is done after the second.
 */
function autotag_form_submit($form, &$form_state){
  if(isset($form_state['storage']['formbuttons'])){
    // After first page we store the form so that it can be restored on the second
    // page
    $form_state['storage']['formsubmitted'] = $form;
  } else {
    if(isset($form_state['clicked_button']['#post']['files'])){
      foreach($form_state['clicked_button']['#post']['files'] as $key => $value){
        // If we have a node, then the files may already be associated.
        $fids_to_ignore = array();
        if(isset($form['#node']->nid)){
          // Lets get a list of the FIDs that are already in the upload table
          $results = db_query("SELECT DISTINCT fid FROM upload WHERE nid = %d", $form['#node']->nid);
          while($row = db_fetch_array($results)){
            $fids_to_ignore[$row['fid']] = $row['fid'];
          }
        }
        if(!isset($fids_to_ignore[$key])){
          $form_state['values']['files'][$key] = db_fetch_array(db_query("SELECT * FROM files WHERE fid = %d", $key));
          $form_state['values']['files'][$key]['new'] = 1;
          $form_state['values']['files'][$key]['list'] = 1;
        }
      }
    }
    
    // Restore the hidden form fields from the old form for taxonomy
    module_load_include('functions.inc','autotag');
    $hide_vids = _autotag_get_vids_for_type($form['type']['#value']);
    foreach($form['taxonomy'] as $key=>$value){
      if(in_array($key,$hide_vids)){
        $form_state['values']['taxonomy'][$key] = $form_state['storage']['oldtaxonomy'][$key]['#default_value'];
      }
    }
    // Unset storage to ensure the form isn't presented to the user again.
    unset($form_state['storage']['oldtaxonomy']);
  }
}
/**
 * Implementation of hook_form_alter
 */
function autotag_form_alter(&$form, &$form_state, $form_id){
  module_load_include('form_alter.inc','autotag');
  module_load_include('functions.inc','autotag');
  _autotag_form_alter($form, $form_state, $form_id);
}