<?php
/* $Id$ */

/** 
 * @file autotag.module
 * Automatically tags nodes with terms depending on the content of textfields.
 * Textfields to use are currently configurable (HOW?).
 */

/**
 * Implementation of hook_nodeapi
 * 
 * This does all the work for this module. When a node is changed/whatever, this
 * checks to see if the node->type is associated with a vocabulary, and if so, it
 * checks to see if any of the vocabulary terms are present in fields in this node.
 */
function autotag_nodeapi($node, $op, $a3 = NULL, $a4 = NULL){
  switch($op){
    case 'submit':
    case 'update':
    case 'alter':
      $node = _autotag_search($node);
    default:
      // Do nothing
      break;
  }
}

/**
 * Following function gets the terms from the database, and does the tagging
 */
function _autotag_search($node){
  // First get all vocabularies, and see which ones apply to this content type
  $vocabularies = taxonomy_get_vocabularies();
  $vids = array();
  foreach($vocabularies as $vocabulary){
    if(in_array($node->type,$vocabulary->nodes) && $vocabulary->tags == 0){
      $vids[] = $vocabulary->vid;
    }
  }
  // Get all the fields to search from this node  
  $fields = _autotag_fields_to_search($node);
  // Get total number to search
  $vids_string = implode(",",$vids);
  $result = db_query("SELECT COUNT(*) FROM {term_data} t LEFT JOIN {term_synonym} s ON t.tid = s.tid  WHERE t.vid IN (".$vids_string.")");
  $total_terms = array_pop(db_fetch_array($result));
  // Search 100 terms at a time (Drupal memory shite)
  for($i=0; $i < $total_terms; $i+=100){
    $results = db_query_range("SELECT vid, t.tid AS tid, lower(t.name) AS name, lower(s.name) AS synonym FROM {term_data} t LEFT JOIN {term_synonym} s ON t.tid = s.tid WHERE vid IN (".$vids_string.")",$i,100);
    while($row = db_fetch_array($results)){
      // Is this term to be found anywhere in this node
      foreach($fields as $field){
        if(isset($node->$field)){
          if(_autotag_search_field($node->$field, $row['name'], $row['synonym'])){
            if(isset($node->taxonomy[$row['vid']]) && is_array($node->taxonomy[$row['vid']]) && count($node->taxonomy[$row['vid']])>0){
              if(!in_array($row['tid'],$node->taxonomy[$row['vid']])){
                $node->taxonomy[$row['vid']][$row['tid']] = $row['tid'];
              }
            } else {
              if($node->taxonomy[$row['vid']]!=""){
                $node->taxonomy[$row['vid']] = array($row['tid']=>$row['tid'],$node->taxonomy[$row['vid']]=>$node->taxonomy[$row['vid']]);
              } else {
                $node->taxonomy[$row['vid']] = array($row['tid']=>$row['tid']);
              }
            }
          }
        }
      }
    }
  }
  return $node;
}

/**
 * Implementation of hook_cron
 * 
 * This function looks over old node content, and tags it in the same way as if it had been
 * edited/created after this module was installed.
 */
function autotag_cron(){
  // Get the last node to be updated with cron.
  $last_nid = variable_get('autotag_last_node',0);
  $highest_nid = variable_get('autotag_cron_highest_nid',2147483647);
  $num_to_update = variable_get('autotag_nodes_to_search',50);
  $results = db_query("SELECT nid FROM {node} WHERE nid > %d AND nid < %d ORDER by nid ASC LIMIT %d", $last_nid, $highest_nid, $num_to_update);
  while($row = db_fetch_array($results)){
    $node = node_load($row);
    _autotag_search($node);
    node_save($node);
    $last_nid = $node->nid;
  }
  variable_set('autotag_last_node', $last_nid);
}
/**
 * Takes a field and term and checks for a match.  Field can be an array, or
 * a single string
 */
function _autotag_search_field($field, $term, $synonym){
  if(is_array($field) || is_object($field)){
    // Field is an array (and likely to be an array of arrays).  Lets
    // recurse into it and check away
    foreach($field as $field_part=>$value){
      if(_autotag_search_field($value, $term, $synonym)){
        return true;
      }
    }
  } else {
    // Field is raw text search it for stuff
    if(strpos(strtolower($field), $term)!== false){
      return true;
    }
    elseif(strpos(strtolower($field), $synonym)!== false){
      return true;
    }
  }
  return false;
}
/**
 * Function simply returns an array of fields to search when given a node
 */
function _autotag_fields_to_search($node){
  $fields = array();
  $ignore_fields = array(
    'nid','vid','status','type','created','comment','changed','promote','sticky','revision_timestamp','log','format','uid','name','picture','data','path','last_comment_timestamp','last_comment_name','comment_count','files','iid','taxonomy','readmore','content','links'
  );
  $adminset_ignore_fields = variable_get('autotag_selectfields_'.$node->type , array());
  foreach($adminset_ignore_fields as $field=>$value){
    if($value !== 0){
      $ignore_fields[] = $field;
    }
  }
  foreach($node as $key=>$value){
    if(!in_array($key, $ignore_fields)){
      $fields[] = $key;
    }
  }
  return $fields;
}

/**
 * Implementation of hook_menu
 * 
 * Needed only for the module's settings page
 */
function autotag_menu($maycache){
  $items = array();
  if (!$may_cache) {
    $items[] = array(
      'path' => 'admin/settings/autotag',
      'title' => t('Autotag settings'),
      'description' => t('Change the default autotag settings to include or exclude fields when auto tagging content.'),
      'callback' => 'drupal_get_form',
      'callback arguments' => array('autotag_admin_settings'),
      'access' => user_access('administer site configuration')
    );
  }
  return $items;
}
/**
 * Autotag settings page
 */
function autotag_admin_settings() {
  // Get the messages so that they can be set afterwards
  $messages = drupal_get_messages();
  // Get all the content types to show on the form
  $content_types = node_get_types('types');
  $form = array();
  // Field for setting number of nodes to update on Cron.
  $options = array();
  for($i=10;$i<=100;$i+=10){$options[$i]=$i;}
  for($i=150;$i<=1000;$i+=50){$options[$i]=$i;}
  $form['autotag_nodes_to_search'] = array(
    '#title' => t('Number of nodes to update on cron'),
    '#type' => 'select',
    '#description' => t('Sets the number of nodes to automatically tag when cron is run.  This allows for content created before the module was installed to be automatically tagged.'),
    '#default_value' => variable_get('autotag_nodes_to_search',50),
    '#options' => $options
  );
  foreach($content_types as $type){
    $options = array();
    $type = $type->type;
    // Fieldset for each content type
    $form[$type] = array('#type'=>'fieldset','#title'=>$type,'#collapsible'=>true,'#collapsed'=>true);
    $newform = content_admin_display_overview_form($type);
    foreach($newform['fields'] as $fieldname => $fieldarray){
      if($fieldarray['type']['#value'] == 'Text'){
        $options[$fieldname]=$fieldname;
      }
    }
    if(function_exists($type.'_form')){
      $newform = call_user_func($type.'_form');
      foreach($newform as $field=>$fieldarray){
        if(in_array('textfield',$fieldarray) || in_array('textarea',$fieldarray)){
          $options[$field]=$field;
        }
      }
    } else {
      $options['title']='title';
      $options['body']='body';
    }
    // Checkboxes for this content type
    $form[$type]['autotag_selectfields_'.$type] = array(
      '#type' => 'checkboxes',
      '#title' => t("Fields to ignore in content type '%type'",array('%type'=>$type)),
      '#description' => t('Uncheck a field if you don\'t want it to be search for taxonomy terms'),
      '#options'=> $options,
      '#default_value'=>variable_get('autotag_selectfields_'.$type , array())
    );
  }
  // Clear the messages set by content types with no extra fields
  drupal_get_messages(null,true);
  // Reset the old messages
  foreach($messages as $type=>$messagearray){
    foreach($messagearray as $message){
      drupal_set_message($message,$type);
    }
  }
  return system_settings_form($form);
}