<?php
/* $Id$ */

/** 
 * @file autotag.module
 * Automatically tags nodes with terms depending on the content of textfields.
 * Textfields to use are currently configurable (HOW?).
 */

/**
 * Implementation of hook_nodeapi
 * 
 * This does all the work for this module. When a node is changed/whatever, this
 * checks to see if the node->type is associated with a vocabulary, and if so, it
 * checks to see if any of the vocabulary terms are present in fields in this node.
 */
function autotag_nodeapi($node, $op, $form = NULL, $a4 = NULL){
  switch($op){
    case 'validate':
      $node = _autotag_search($node, $form);
    default:
      // Do nothing
      break;
  }
}

/**
 * Following function gets the terms from the database, and does the tagging
 */
function _autotag_search($node, $form){
  // First get all vocabularies, and see which ones apply to this content type
  $vocabularies = taxonomy_get_vocabularies();
  $vids = array();
  foreach($vocabularies as $vocabulary){
    if(in_array($node->type,$vocabulary->nodes) && $vocabulary->tags == 0){
      $vids[] = $vocabulary->vid;
    }
  }
  // Get all the fields to search from this node  
  //print_r($form);exit;
  $fields = _autotag_fields_to_search($form, _autotag_fields_to_ignore($node));
  print_r($fields);exit;
  // Get total number to search
  $vids_string = implode(",",$vids);
  $result = db_query("SELECT COUNT(*) FROM {term_data} t LEFT JOIN {term_synonym} s ON t.tid = s.tid  WHERE t.vid IN (".$vids_string.")");
  $total_terms = array_pop(db_fetch_array($result));
  // Search 100 terms at a time (Drupal memory shite)
  for($i=0; $i < $total_terms; $i+=100){
    $results = db_query_range("SELECT vid, t.tid AS tid, lower(t.name) AS name, lower(s.name) AS synonym FROM {term_data} t LEFT JOIN {term_synonym} s ON t.tid = s.tid WHERE vid IN (".$vids_string.")",$i,100);
    while($row = db_fetch_array($results)){
      // Is this term to be found anywhere in this node
      foreach($fields as $field){
        if(isset($node->$field)){
          if(_autotag_search_field($node->$field, $row['name'], $row['synonym'])){
            if(isset($node->taxonomy[$row['vid']]) && is_array($node->taxonomy[$row['vid']]) && count($node->taxonomy[$row['vid']])>0){
              if(!in_array($row['tid'],$node->taxonomy[$row['vid']])){
                $node->taxonomy[$row['vid']][$row['tid']] = $row['tid'];
              }
            } else {
              if($node->taxonomy[$row['vid']]!=""){
                $node->taxonomy[$row['vid']] = array($row['tid']=>$row['tid'],$node->taxonomy[$row['vid']]=>$node->taxonomy[$row['vid']]);
              } else {
                $node->taxonomy[$row['vid']] = array($row['tid']=>$row['tid']);
              }
            }
          }
        }
      }
    }
  }
  return $node;
}

/**
 * Takes a field and term and checks for a match.  Field can be an array, or
 * a single string
 */
function _autotag_search_field($field, $term, $synonym){
  if(is_array($field) || is_object($field)){
    // Field is an array (and likely to be an array of arrays).  Lets
    // recurse into it and check away
    foreach($field as $field_part=>$value){
      if(_autotag_search_field($value, $term, $synonym)){
        return true;
      }
    }
  } else {
    // Field is raw text search it for stuff
    if(strpos(strtolower($field), $term)!== false){
      return true;
    }
    elseif(strpos(strtolower($field), $synonym)!== false){
      return true;
    }
  }
  return false;
}

/**
 * Return a list of fields to ignore _always_
 */
function _autotag_fields_to_ignore(){
  return array(
    'nid', 'vid', 'created', 'uid', 'type', 'changed', 'log', 'author', 'preview', 'submit', 'delete'
  );
}
/**
 * Function simply returns an array of fields to search when given a node
 */
function _autotag_fields_to_search($form, $fields_to_ignore, $parent_type=""){
  // Parse through the form, returning any fields which are "textfield" or "textarea"
  /*
  $fields_to_return = array();
  foreach($form as $key=>$value){
    if(is_array($value) || is_object($value)){
      if(substr($key,0,1)!='#' && !in_array($key, $fields_to_ignore)){
        $fields =_autotag_fields_to_search($value, $fields_to_ignore, $key);
        if(count($fields)){
          $fields_to_return = array_merge($fields, $fields_to_return);
        }
      }
    } else {
      if($key=='#type' && ($value=='textfield' || $value=='textarea') && substr($parent_type,0,1)!='#'){
        $fields_to_return[$parent_type] = $parent_type;
      }
    }
  }
  return $fields_to_return;
  */
  
  $return_fields = array();
  /**
   * Following function does the work.  Only needed in this function, hence why it is nested.
   */
  function field_parse($field_array){
    foreach($field_array as $key=>$value){
      if(is_array($value)||is_object($value)){
        return field_parse($value);
      }
      elseif($key=='#type' && ($value=='textarea'||$value=='textfield')){
        echo "*";
        return true;
      }
    }
  }
  // Go through each of the root parts and see if it has a textarea or textfield in it
  foreach($form as $field_name => $field_value){
    if(!in_array($field_name, $fields_to_ignore) && substr($field_name,0,1)!='#'){
      if(field_parse($field_value)){
        echo "#";
        $return_fields[]= $field_name;
      }
    }
  }
  return $return_fields;
}

/**
 * Autotag settings page
 * 
 * This allows the user to set:
 * 
 * - Vocabularies to associate with a particular content type
 */