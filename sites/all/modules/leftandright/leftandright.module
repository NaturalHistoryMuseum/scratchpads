<?php
/* $Id$*/
/* $HeadURL$*/

/** 
 * @file leftandright.module
 * 
 * Adds a left and right table which is linked to the taxonomy tables that in 
 * turn enables the retrieval of trees to be much quicker.  It's just magic
 * really.
 * 
 * Changes to this module since D5
 * - Only forces itself on large taxonomies (>2000 terms).
 * - Better coding (Christ alive eating a banana, my code can be pants at times)
 */

/*******************************************************************************
 * HOOKS
 ******************************************************************************/
// hook_menu
function leftandright_menu(){
  $items['admin/content/taxonomy/leftandright'] = array(
    'title' => 'Rebuild Tree',
    'page callback' => 'leftandright_overview_vocabularies',
    'access arguments' => array('administer taxonomy'),
    'file' => 'leftandright.admin.inc',
    'type' => MENU_LOCAL_TASK);
  $items['leftandright/update'] = array(
    'title' => '',
    'description' => '',
    'page callback' => 'leftandright_rebuild_tree_page',
    'access arguments' => array('administer site configuration'),
    'type' => MENU_CALLBACK
  );
  $items['admin/content/taxonomy/%'] = array(
    'title' => 'List terms',
    'page callback' => 'leftandright_overview_terms',
    'page arguments' => array(3),
    'access arguments' => array('administer taxonomy'),
    'type' => MENU_CALLBACK,
    'file' => 'leftandright.admin.inc'
  );
  return $items;
}

// hook_help
function leftandright_help($path, $arg) {
  switch ($path) {
    case 'admin/content/taxonomy/leftandright':
      return '<p>'. t('Click to rebuild a tree.  There is usually no need to rebuild a tree manually, however, if you\'ve been experiencing unusual results from taxonomic queries, then this may help.') .'</p>';
      break;
    case 'admin/content/taxonomy':
      return '<p>'.t('Taxonomies with greater than @leftandright_minimum terms will use the <a href="http://drupal.org/project/leftandright">Left and right module</a> for improved performance.  Unfortunately this means that these taxonomies no longer support the reordering of terms.', array('@leftandright_minimum'=>variable_get('leftandright_minimum_terms',1000))).'</p>';
      break;
  }
}

/**
 * The following function adds the data to the left and right table when a new
 * term is added to the site, or it alters the data if the parent of a term is
 * changed, or if the name itself is changed.  etc
 */
// hook_taxonomy
function leftandright_taxonomy($op, $type, $array = NULL){
  if($type=='term'){
    // First check that this terms vocabulary uses leftandright
    if(leftandright_use_leftandright($array['vid'])){
      switch($op){
        case 'delete':
          // Easy, just delete the term from leftandright!
          db_query('DELETE FROM {leftandright} WHERE tid=%d',$array['tid']);
          break;
        case 'update':
        case 'insert':
           module_load_include("functions.inc", "leftandright");
           leftandright_hook_taxonomy_helper_insert($array);
           // Finally update the variable storing the total number of terms in
           // each of the vocabularies.
           leftandright_update_totals_variable();
      }
    }
  }
}

/**
 * Following function updates the numbers in the leftandright_something_blah
 * variable
 */
// hook_form_alter
function leftandright_form_alter($form, $form_state, $form_id){
  // Rebuild the numbers if we're looking at the main taxonomy page
  if($form_id == 'taxonomy_overview_vocabularies'){
    leftandright_update_totals_variable();
  }
  
  // Remove the weight field if we're on a term edit page and this vocabulary
  // uses leftandright
  if($form_id == 'taxonomy_form_term'){
    unset($form['advanced']['weight']);
  }
}
/*******************************************************************************
 * ADDITIONAL leftandright FUNCTIONS FOR OTHER MODULES!
 ******************************************************************************/
/**
 * Following function returns TRUE if this term or one of its descendants
 * has been used to tag a node, FALSE if not.
 */
function leftandright_descendant_used($tid){
  //return false;
  $result = db_query("SELECT COUNT(*) FROM {term_node} WHERE tid IN (SELECT tid FROM {leftandright} WHERE lft>=(SELECT lft FROM {leftandright} WHERE tid=%d) AND rgt<=(SELECT rgt FROM {leftandright} WHERE tid=%d))",$tid,$tid);
  if(array_pop(db_fetch_array($result))){
    return true;
  } else {
    return false;
  }
}

/**
 * Following function returns true if a vocabulary has more than the minimum
 * number of terms required to use "leftandright"
 */
function leftandright_use_leftandright($vid){
  if(is_array($vid)){
    foreach($vid as $single_vid){
      if(!leftandright_use_leftandright($single_vid)){
        return false;
      }
    }
    return true;
  }
  $totals = variable_get('leftandright_vocab_totals', false);
  if(!$totals){
    leftandright_update_totals_variable();
    $totals = variable_get('leftandright_vocab_totals', false);    
  }
  if($totals){
    if($totals[$vid]>variable_get('leftandright_minimum_terms', 1000)){
      return true;
    }
  }
  return false;
}

/**
 * Update the variable
 */
function leftandright_update_totals_variable(){
  $result = db_query("SELECT COUNT(*) count, vid FROM term_data GROUP BY vid");
  $totals = array();
  while($row = db_fetch_array($result)){
    $totals[$row['vid']] = $row['count'];    
  }
  variable_set('leftandright_vocab_totals', $totals);
}

/*******************************************************************************
 * REPLACEMENT FUNCTIONS FOR taxonomy module
 ******************************************************************************/
function leftandright_get_tree($vid, $parent, $max_depth, $offset = 0, $count=1000){
  $lftandrgt_sql = '';
  $params = array($vid);
  if($parent != 0){
    $results = db_query("SELECT lft,rgt,depth FROM {leftandright} WHERE tid = %d", $parent);
    $row = db_fetch_array($results);
    $left = $row['lft'];
    $right = $row['rgt'];
    if(isset($max_depth) && $max_depth != NULL){
      $max_depth += $row['depth']+1;
    }
    $lftandrgt_sql = 'AND lft>%f AND rgt <%f';
    $params[] = $left;
    $params[] = $right; 
  }
  $depth_sql = '';
  if(isset($max_depth) && $max_depth != NULL){
    $depth_sql = 'AND depth<%d';
    $params[] = $max_depth;
  }
  $params[] = $offset;
  $params[] = $count;
  db_query_temporary("SELECT lft, tid, depth FROM {leftandright} WHERE vid = %d $lftandrgt_sql $depth_sql ORDER BY lft LIMIT %d,%d", $params, 'leftandrighttemp');
  $tree = array();
  // FIXME - We're not returning the parents for a term - is this an issue?
  // leftandrighttemp doesn't need {}
  $results = db_query("SELECT t.*, depth FROM {term_data} t, leftandrighttemp l WHERE t.tid = l.tid ORDER BY lft", $tids);
  while($row = db_fetch_object($results)){
    $tree[] = $row;
  }
  // Hmmm, we need to drop the temporary table - FFS, I thought the whole idea
  // of a temporary table was I could just whack it in there! Oh well.
  db_query("DROP TEMPORARY TABLE leftandrighttemp");
  return $tree;
}

// FIXME - This doesn't use the max_depth variable
function leftandright_get_tree_count($vid, $parent = 0, $max_depth = NULL){
  // Get parent left and right
  $lftandrgt_sql = '';
  $arguments = array($vid);
  if($parent != 0){
    $results = db_query("SELECT lft,rgt,depth FROM {leftandright} WHERE tid = %d", $parent);
    $row = db_fetch_array($results);
    $arguments[] = $row['lft'];
    $arguments[] = $row['rgt'];
    //$max_depth += $row['depth']; // Is this right???
    $lftandrgt_sql = 'AND lft>=%f AND rgt <=%f';
  }
  return array_pop(db_fetch_array(db_query("SELECT COUNT(*) FROM {leftandright} WHERE vid=%d $lftandrgt_sql", $arguments)));
}

// Hmmm, does this need rewriting to use db_rewrite_query?? FIXME
function leftandright_select_nodes($tids, $operator, $depth, $pager, $order) {
  if (count($tids) > 0) {
    if($depth =='all'){
      $depth = null;
    }
    $leftandrights = array();
    foreach($tids as $tid){
      $result = db_query("SELECT lft,rgt,depth FROM {leftandright} WHERE tid = %d",$tid);
      $row = db_fetch_array($result);
      $sql = "(lft>=".$row['lft']." AND rgt<=".$row['rgt'];
      if(isset($depth) && $depth!=null){
        $sql .= "AND depth<=".$row['depth']+$depth;
      }
      $sql .= ")";
      $leftandrights[] = $sql;
    }
    $sql = "SELECT DISTINCT(n.nid), n.sticky, n.title, n.created FROM {node} n, {term_node} t, {leftandright} l WHERE t.nid = n.nid AND l.tid=t.tid AND (".implode(" $operator ",$leftandrights).") ORDER BY ".$order;
    if ($pager) {
      $result = pager_query($sql, variable_get('default_nodes_main', 10), 0, $sql_count, $args);
    }
    else {
      $result = db_query_range($sql, $args, 0, variable_get('feed_default_items', 10));
    }
  }
  return $result;  
}
/*******************************************************************************
 * REBUILD TREE
 ******************************************************************************/
// Returns an indexed array of PIDs and the vocabularies associated with these PIDs
function leftandright_trees_rebuilding($vid = 0){
  exec('ps -ef | grep landr | grep -v grep',$exec_output);
  $rebuilding=array();
  foreach($exec_output as $process){
    // Split the process by " " as the last part should be the vocabulary ID
    $parts = explode(" ",preg_replace("/[\ ]*\ /"," ",$process));
    $exec_vid = array_pop($parts);
    if($vid == $exec_vid){
      return true;
    }
    $pid = $parts[1];
    $rebuilding[$pid]=$exec_vid;
  }
  if($vid){
    return false;
  } 
  return $rebuilding;
}
function leftandright_rebuild_tree_page($vid){
  if(leftandright_trees_rebuilding($vid)){
    drupal_set_message(t('Already rebuilding vocabulary'));
  } else {
    if(leftandright_use_leftandright($vid)){
      leftandright_rebuild_tree($vid);
    } else {
      drupal_set_message(t('Vocabulary has too few terms to use Left and right'));
    }
  }
  drupal_goto('admin/content/taxonomy/leftandright');
}
function leftandright_rebuild_tree($vid){
  module_load_include("rebuild.inc", "leftandright");
  _leftandright_rebuild_tree($vid);
}