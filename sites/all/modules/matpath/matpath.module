<?php
/** 
 * @file matpath.module
 * 
 * Materialised Path implementation for Drupal Taxonomy.
 * 
 * This file replaces three functions from Drupal's Taxonomy module, making them
 * use materialised path SQL queries, as opposed to using recursive PHP/SQL functions.
 * 
 * Justification for this module arrose for us through the very large taxonomies
 * that occur in Biological Taxonomy (the process of categorising every species
 * on the planet).  The current Catalogue of Life classification for example has
 * over 2M terms in it, a figure which the current Drupal implementation of taxonomy
 * can only dream of being able to handle.
 * 
 * The main function that is replaced by this module is taxonomy_get_tree.  This is 
 * the function that loads all of a taxonomy into memory, resulting in "Out of memory"
 * exceptions.  It is rare that a whole taxonomy is needed to be loaded into memory,
 * drop down boxes with over 100 terms in are unpractical (see batax module), whilst
 * loading the whole tree to only display part of it on a vocabulary overview page
 * is incredibly inefficient.
 */
/***********************************************************************************
 * HOOKS
 ***********************************************************************************/
/**
 * The following function adds the data to the matpath table when a new term is
 * added to the site, or if alterations change the paths for the term.  It is these
 * functions that Drupal core should look at emulating in futurue versions of Drupal.
 */
function matpath_taxonomy($op, $type, $array = NULL){
  if($type=='term'){
    switch($op){
      case 'delete':
        // Deletion of a term moves its children to its parent:
        // Delete "B"
        // A -> B -> C  becomes A -> C
        // This behaviour could be changed quite easily, we could have options for the 
        // following on deleting a term:
        // - All children are also deleted
        // - Children are moved up to the terms parent (* Selected)
        // - Children become orphans, with no parents.
        
        // Get the current path(s) of this term, this will allow us to get all the children.
        // We can also calculate the parent path(s) from this/these path(s).
        $results = db_query("SELECT path FROM {matpath} WHERE tid = %d", $array['tid']);
        while($row = db_fetch_array($results)){
          // For each of this term's paths, move the children up.
          $path = array_pop($row);
          $new_path = substr($path, 0, strrpos($path,"/"));
          // This is just one SQL query - magic
          db_query("UPDATE {matpath} SET path = REPLACE(path, '%s', '%s') WHERE path LIKE '%s%%'", $path, $new_path, "$path/");
        }
        // Finally, delete the term
        db_query("DELETE FROM {matpath} WHERE tid = %d", $array['tid']);

      case 'update':
        // Operations that will result in a change to the database structure are:
        // - Added/changing the parent(s) of a term
        // - Changing the term text so that it is ordered above or below other terms
        // - Changing the weight of a term so that it is ordered above or below other terms
        
        // We therefore need to calculate the paths that this term should occupy from the submitted
        // form values, and check those against the ones in the database.  If these differ, then
        // changes are required, if they don't differ, then no changes are required.
        $results = db_query("SELECT path FROM {matpath} WHERE tid = %d");
        $db_paths = array();
        while($row = db_fetch_array($results)){
          $db_paths[] = array_pop($row);
        }
        // Get the paths that we'd like to have set, based on the parents
        // array values
        $paths = matpath_calculate_paths_from_parents($array['parents']);
        // Now lets compare the two arrays.
        // Anything in both can be ignored
        // Anything in db_paths, but not in paths needs removing
        // Anything in paths, but not in db_paths needs adding.  Additions will need to have the children
        //   added also.
        if(count($paths)>count($db_paths)){
          // There are paths to add, we'll need a copy of the children
          // Let's create a temporary table to store the children tree (rooted directly below
          // the term that we're updating), this can then be copied for all additional paths
          $results = db_query_temporary("SELECT tid,vid,REPLACE(path,(SELECT path FROM {matpath} WHERE tid = %d LIMIT 1),'') path FROM {matpath} WHERE path LIKE (SELECT CONCAT(path,'/%') FROM {matpath} WHERE tid = %d LIMIT 1)", $array['tid'], $array['tid'], 'matpathtemp');
          
          // We can now look at the paths to add, and add only the required number, as the others
          // will be added by replacing other paths.
          $paths_to_add = array_diff($paths, $db_paths);
          for($i=0; $i<(count($paths)-count($db_paths)); $i++){
            // We'll only add any additional numbers, others can be updated
            $new_path = array_pop($paths_to_add);
            db_query("INSERT INTO {matpath} (tid, vid, path) SELECT tid, vid, CONCAT('%s',path) FROM matpathtemp", $new_path);
          }
          // Let's update the db_paths
          $results = db_query("SELECT path FROM {matpath} WHERE tid = %d");
          $db_paths = array();
          while($row = db_fetch_array($results)){
            $db_paths[] = $row['path'];
          }          
        }
        // Now we can compare db_paths with paths, and update/delete
        $paths_to_add = array_diff($paths, $db_paths);
        $paths_to_remove = array_diff($db_paths, $paths);
        // Work through the paths_to_add, overriding an entry from paths_to_remove
        foreach($paths_to_add as $new_path){
          $old_path = array_pop($paths_to_remove);
          db_query("UPDATE {matpath} SET path = REPLACE(path, '%s', '%s') WHERE path LIKE '%s/%%' OR path = '%s'", $old_path, $new_path, $old_path, $old_path);
        }
        // Finally, remove any left over
        foreach($paths_to_remove as $old_path){
          // No need to worry about children here (I THINK - CHECK THIS)
          db_query("DELETE FROM {matpath} WHERE path LIKE '%s/%%' OR path = '%s'", $old_path, $old_path);
        }
      case 'insert':
        // This is a new term, and therefore won't have any children, inserting is easy.
        $parent_paths = matpath_calculate_paths_from_parents($array['parents'], $array['weight']."-".$array['name']);
        $inserts = array();
        $values = array();
        foreach($parent_paths as $path){
          $inserts[] = "(%d, %d, '%s', %d)";
          $values[] = $array['tid'];
          $values[] = $array['vid'];
          $new_path = "$path/".$array['weight']."-".str_replace("/","",$array['name']);
          $values[] = $new_path;
          $values[] = substr_count($new_path, "/");
        }
        db_query('INSERT INTO matpath (tid, vid, path, depth) VALUES '.implode(",",$inserts), $values);
    }
  }
}
/***********************************************************************************
 * HELPER FUNCTIONS
 ***********************************************************************************/
/**
 * This function calculates the path(s) for a term, based on the parents of the term,
 * and the term itself.  This function is made more complicated by the fact that the
 * term's siblings heavily affect the final element of the path.
 *
 * @param String[] $parents
 * @param Object $term
 */
function matpath_calculate_paths_from_parents($parents, $term){
  // Paths to return array
  $paths = array();
  // Check that parents is array, if not set it so
  if(!is_array($parents)){
    $parents = array($parents);
  }
  foreach($parents as $parent){
    // Get the path of each of the parents, allowing us to select the siblings
    // and calculate the position of this term relative to the siblings
    $results = db_query("SELECT path FROM {matpath} WHERE id = %d", $parent);
    // Note, a parent can have multiple paths, but the position of the siblings
    // below that path is always the same, we can therefore calculate that just
    // once.
    $sibling_position = false;
    while($row = db_fetch_array($results)){
      $path = array_pop($row);
      if($sibling_position === false){
        $sibling_position = 0;
        // Calculate this terms position relative to siblings
        $result = db_query("SELECT name, weight FROM term_data t, matpath m WHERE t.tid=m.tid AND path LIKE '%s%%'", $path);
        while($sibling_row = db_fetch_array($result)){
          // Compare the return row against the term.  If the weight is less, or the
          // term name appears before this terms in the alphabet, then increase the
          // sibling_position by 1
          if($sibling_row['weight']<$term->weight || strcmp($term->name, $sibling_row['name'])){
            $sibling_position ++;
          }
        }
      }
      $paths[] = "$path/$sibling_position";
    }
  }
  return $paths;
}
/**
 * Following function updates all the weights in the matpath table.  This is made
 * possible given the direct relationship between the number of "/" characters in
 * the path, and the weight itself.
 */
function matpath_update_weights($vid, $path='//'){
  db_query("UPDATE matpath SET depth = LENGTH(path)-LENGTH(REPLACE(path,'/',''))-2 WHERE vid=%d AND path LIKE '%s%%'", $vid, $path);
}
/***********************************************************************************
 * TAXONOMY ADDITIONAL PAGE
 ***********************************************************************************/
/**
 * List and manage vocabularies.
function matpath_overview_vocabularies() {
  $rebuilding = matpath_trees_rebuilding();
  $above_table = false;
  if(count($rebuilding)){
    $processes = variable_get('matpath_rebuild_pids',array());
    $current_pids = array();
    foreach($rebuilding as $pid=>$vid){
      // Check that this process was started by this site
      if(in_array($pid,$processes)){
        if(!$above_table){
          $above_table = '<p><strong>'.t('Currently rebuilding the following vocabularies:').'</strong></p><ul>';
        }
        $vocabulary = taxonomy_get_vocabulary($vid);
        $above_table .='<li>'.check_plain($vocabulary->name).'</li>';
        $current_pids[] = $pid;
        $display_above_table = true;
      }
    }
    variable_set('matpath_rebuild_pids',$current_pids);
    $above_table .= '</ul>';
  }
  $vocabularies = taxonomy_get_vocabularies();
  $rows = array();
  foreach ($vocabularies as $vocabulary) {
    if(isset($rebuilding[$vocabulary->vid])){
      $rebuild = t('This tree is currently being rebuilt');
    } else {
      $rebuild = l(t('rebuild tree'), 'matpath/update/'.$vocabulary->vid);
    }
    $rows[] = array(
      'name' => check_plain($vocabulary->name),
      'rebuild' => $rebuild
    );
  }
  if (empty($rows)) {
    $rows[] = array(array('data' => t('No categories available.'), 'colspan' => '5'));
  }
  $header = array(t('Name'),t('Rebuild Tree'));

  return $above_table . theme('table', $header, $rows, array('id' => 'taxonomy'));
}
 */
/***********************************************************************************
 * ADDITIONAL matpath FUNCTIONS FOR OTHER MODULES!
 ***********************************************************************************/
/**
 * Following function returns TRUE if this term or one of its descendants
 * has been used to tag a node, FALSE if not.
 */
function matpath_descendant_used($tid){
  //return false;
  $result = db_query("SELECT COUNT(*) FROM {term_node} WHERE tid IN (SELECT tid FROM {matpath} WHERE lft>=(SELECT lft FROM {matpath} WHERE tid=%d) AND rgt<=(SELECT rgt FROM {matpath} WHERE tid=%d))",$tid,$tid);
  if(array_pop(db_fetch_array($result))){
    return true;
  } else {
    return false;
  }
}
/***********************************************************************************
 * REPLACEMENT FUNCTIONS FOR taxonomy module
 ***********************************************************************************/
function matpath_get_tree($vid, $parent = 0, $max_depth = NULL, $offset = 0, $count=1000){
  // First we do a count, if the tree is too big, we give a warning.
  $tree_size = matpath_get_tree_count($vid, $parent, $max_depth);
  if($tree_size>1000){
    watchdog('taxonomy','Tried to get a big tree [taxonomy_get_tree('.$vid.','.$parent.','.$max_depth.')',WATCHDOG_WARNING);
  }
  $path = '/';
  if($parent != 0){
    $path = array_pop(db_fetch_array(db_query("SELECT path FROM {matpath} WHERE tid = %d", $parent)));
  }
  $params = array($vid, $path);
  $depth_sql = '';
  if(isset($max_depth) && $max_depth != NULL){
    $depth_sql = 'AND depth<%d';
    $params[] = $max_depth;
  }
  $results = db_query_range("SELECT t.tid,t.*,m.depth FROM {term_data} t, {matpath} m WHERE t.tid = m.tid AND m.vid = %d AND path LIKE '%s/%%' $depth_sql ORDER BY path", $params, $offset, $count);
  
  echo db_num_rows($results);
  $tree = array();
  // FIXME - We're not returning the parents for a term - is this an issue?
  while($row = db_fetch_object($results)){
    $tree[] = $row;
  }
  return $tree;
}
function matpath_get_tree_count($vid, $parent = 0, $max_depth = NULL){
  // Get parent left and right
  $path = "/";
  if($parent != 0){
    $path = array_pop(db_fetch_array(db_query("SELECT path FROM {matpath} WHERE tid = %d", $parent)));
  }
  $count = array_pop(db_fetch_array(db_query("SELECT COUNT(*) FROM {matpath} WHERE vid=%d AND path LIKE '%s/%%'", $vid, $path)));
  return sprintf("SELECT COUNT(*) FROM {matpath} WHERE vid=%d AND path LIKE '%s/%%'", $vid, $path);
}
function matpath_select_nodes($tids = array(), $operator = 'or', $depth = 0, $pager = TRUE, $order = 'n.sticky DESC, n.title ASC ') {
  if (count($tids) > 0) {
    if($depth =='all'){
      $depth = null;
    }
    $matpaths = array();
    foreach($tids as $tid){
      $result = db_query("SELECT lft,rgt,depth FROM {matpath} WHERE tid = %d",$tid);
      $row = db_fetch_array($result);
      $sql = "(lft>=".$row['lft']." AND rgt<=".$row['rgt'];
      if(isset($depth) && $depth!=null){
        $sql .= "AND depth<=".$row['depth']+$depth;
      }
      $sql .= ")";
      $matpaths[] = $sql;
    }
    $sql = "SELECT DISTINCT(n.nid), n.sticky, n.title, n.created FROM {node} n, {term_node} t, {matpath} l WHERE t.nid = n.nid AND l.tid=t.tid AND (".implode(" $operator ",$matpaths).") ORDER BY ".$order;
    if ($pager) {
      $result = pager_query($sql, variable_get('default_nodes_main', 10), 0, $sql_count, $args);
    }
    else {
      $result = db_query_range($sql, $args, 0, variable_get('feed_default_items', 10));
    }
  }
  return $result;  
}
/**
 * Following function is barely changed from the original, but just to make things simpler, it's recreated here.
 */
function matpath_overview_terms($vid){
  $destination = drupal_get_destination();

  $header = array(t('Name'), t('Operations'));
  $vocabulary = taxonomy_get_vocabulary($vid);
  if (!$vocabulary) {
    return drupal_not_found();
  }

  drupal_set_title(check_plain($vocabulary->name));
  $start_from      = $_GET['page'] ? $_GET['page'] : 0;
  $total_entries   = 0;  // total count for pager
  $page_increment  = 25; // number of tids per page
  $displayed_count = 0;  // number of tids shown

  if ($vocabulary->tags) {
    // We are not calling taxonomy_get_tree because that might fail with a big
    // number of tags in the freetagging vocabulary.
    $results = pager_query(db_rewrite_sql('SELECT t.*, h.parent FROM {term_data} t INNER JOIN  {term_hierarchy} h ON t.tid = h.tid WHERE t.vid = %d ORDER BY weight, name', 't', 'tid'), $page_increment, 0, NULL, $vid);
    while ($term = db_fetch_object($results)) {
      $rows[] = array(
        l($term->name, "taxonomy/term/$term->tid"),
        l(t('edit'), "admin/content/taxonomy/edit/term/$term->tid", array(), $destination),
      );
    }
  }
  else {
    $total_entries = matpath_get_tree_count($vid);
    $tree = matpath_get_tree($vocabulary->vid, 0,NULL,$start_from*$page_increment,$page_increment);
    foreach ($tree as $term) {
      $total_entries++; // we're counting all-totals, not displayed
      if (($start_from && ($start_from * $page_increment) >= $total_entries) || ($displayed_count == $page_increment)) {
        continue;
      }
      $rows[] = array(str_repeat('--', $term->depth) .' '. l($term->name, "taxonomy/term/$term->tid"), l(t('edit'), "admin/content/taxonomy/edit/term/$term->tid", array(), $destination));
      $displayed_count++; // we're counting tids displayed
    }
    if (!$total_entries) {
      $rows[] = array(array('data' => t('No terms available.'), 'colspan' => '2'));
    }
    $GLOBALS['pager_page_array'][] = $start_from;
    $GLOBALS['pager_total'][] = intval($total_entries / $page_increment);
  }
  $output .= theme('table', $header, $rows, array('id' => 'taxonomy'));
  if ($vocabulary->tags || $total_entries >= $page_increment) {
    $output .= theme('pager', NULL, $page_increment);
  }
  return $output;
  
}
/***********************************************************************************
 * REBUILD TREE
 ***********************************************************************************/
// Returns an indexed array of PIDs and the vocabularies associated with these PIDs
function matpath_trees_rebuilding(){  
  exec('ps -ef | grep landr | grep -v grep',$exec_output);
  $rebuilding=array();
  foreach($exec_output as $process){
    // Split the process by " " as the last part should be the vocabulary ID
    $parts = explode(" ",preg_replace("/[\ ]*\ /"," ",$process));
    $vid = array_pop($parts);
    $pid = $parts[1];
    $rebuilding[$pid]=$vid;
  }
  return $rebuilding;
}
function matpath_rebuild_tree_page($args){
  matpath_rebuild_tree($args);
  drupal_goto('admin/content/taxonomy/matpath');
}
function matpath_rebuild_tree($vid){
  // Lets load this vocabulary, firstly to make sure it exists, and secondly
  // so that we know its name
  $vocabulary = taxonomy_get_vocabulary($vid);
  if(!$vocabulary){return;}
  // Check that the vocabulary has terms, if not, just return
  $result = db_query("SELECT COUNT(tid) c FROM {term_data} WHERE vid = %d", $vid);
  $array_results = db_fetch_array($result);
  if(!$array_results['c']){
    drupal_set_message(check_plain($vocabulary->name).' has no terms');
    return;
  }
  
  // Get the DB connection shit in the same way as core does
  global $db_url;  
  $url = parse_url($db_url);
  $url['user'] = urldecode($url['user']);
  if(isset($url['pass'])) {
    $url['pass'] = urldecode($url['pass']);
  } else {
    $url['pass'] = '';}
  $url['host'] = urldecode($url['host']);
  $url['path'] = urldecode($url['path']);
  $url['port'] = $url['port'] ? $url['port'] : 3306;
  
  // Calculate the tid to start from (creating a parent if the vocabulary
  // has multiple roots (forest not tree).
  $results = db_query("SELECT t.tid FROM {term_data} t, {term_hierarchy} h WHERE parent = 0 AND vid = %d AND t.tid = h.tid;", $vid);
  $tid;
  $temporary_root_created = false;
    
  if(db_num_rows($results)==1){
    // Single tree, woot
    $tid = array_pop(db_fetch_array($results));
  } else {
    $temporary_root_created = true;
    // Either no results (Farp), Or we have a forest.  Lets tree it!
    // Create new term to be the base of the tree.
    // Because the term is temporary, we don't use taxonomy_ functions, but instead
    // use trusty SQL.
    $tid = db_next_id('{term_data}_tid');
    // Create term
    db_query("INSERT INTO {term_data} (tid, vid, name) VALUES (%d , %d , 'TEMPORARY TERM')", $tid, $vid);
    db_query("INSERT INTO {term_hierarchy} (tid, parent) VALUES (%d , 0)", $tid);
    // Set parent of current roots as this term
    $result = db_query("SELECT t.tid FROM {term_hierarchy} h, {term_data} t WHERE t.tid = h.tid AND parent =0 AND vid = %d AND t.tid != %d",$vid, $tid);
    $tids = array();
    while($row=db_fetch_array($result)){
      $tids[] = $row['tid'];
    }
    db_query("UPDATE {term_hierarchy} SET parent = %d WHERE tid IN (".implode(",",$tids).")",$tid,$tid);
  }
  
  // Create the string which will become the PHP file to execute
  /**
   * FIXME - The following doesn't use Drupal's {table_name} shenanigans
   */  
  $tmp_php_file_string = '<?php
mysql_connect(\''.$url['host'].'\',\''.$url['user'].'\',\''.$url['pass'].'\','.$url['port'].');
mysql_select_db(\''.substr($url['path'], 1).'\');
function rebuild_tree($tid, $left, $depth) {
  $right = $left+1;
  $results = mysql_query("SELECT h.tid FROM '.db_prefix_tables('{term_hierarchy}').' h,'.db_prefix_tables('{term_data}').' t  WHERE parent = $tid AND t.tid=h.tid ORDER BY weight ASC , name DESC");
  while ($row = mysql_fetch_array($results)){
    $right = rebuild_tree($row[0], $right, $depth+1);
  }  
  echo "($tid , '.$vid.' , $left , $right, $depth)";
  if($left != 1){
    echo ",";
  }
  return $right+1;
} 
echo "DELETE FROM '.db_prefix_tables('{matpath}').' WHERE vid = '.$vid.'; INSERT INTO '.db_prefix_tables('{matpath}').' (tid, vid, lft, rgt, depth) VALUES ";
rebuild_tree('.$tid.',1, ';
  if($temporary_root_created){
    $tmp_php_file_string .= '-1';
  } else {
    $tmp_php_file_string .= '0';    
  }
  $tmp_php_file_string .= ');
echo ";";';
  
  // Add the deletion of the temporary term if required to the PHP file
  if($temporary_root_created){
    $tmp_php_file_string .= '
echo "DELETE FROM '.db_prefix_tables('{matpath}').' WHERE tid = '.$tid.';DELETE FROM '.db_prefix_tables('{term_data}').' WHERE tid = '.$tid.';DELETE FROM '.db_prefix_tables('{term_hierarchy}').' WHERE tid = '.$tid.';";
echo "UPDATE '.db_prefix_tables('{term_hierarchy}').' SET parent = 0 WHERE parent = '.$tid.';";';
  }
  $tmp_php_file_string .= '
echo "UPDATE '.db_prefix_tables('{matpath}').' l SET lowername = (SELECT LOWER(name) FROM '.db_prefix_tables('{term_data}').' t WHERE l.tid = t.tid);";';
  // Write this out to a temporary file which we'll EXEC!
  $filepath = file_create_filename('matpath.php', file_directory_temp());
  file_save_data($tmp_php_file_string, $filepath, FILE_EXISTS_REPLACE);
  
  // FIXME - TEST FOR WINDOWS HERE, IF WINDOWS, EXECUTE BAT FILE INSTEAD
  // Lets try to execute the file
  if($windoze){
    
  } else {
    $file_to_execute = $_SERVER['DOCUMENT_ROOT'].base_path().drupal_get_path('module','matpath').'/landr';
    // FIXME - Needs port
    $command = $file_to_execute.' '.$filepath.' '.$url['host'].' '.$url['user'].' '.$url['pass'].' '.substr($url['path'], 1).' '.$vid;
    $pid = shell_exec("nohup $command > /dev/null & echo $!");
    variable_set('matpath_rebuild_pids',array_merge(variable_get('matpath_rebuild_pids',array()),array($pid=>$pid)));
  }
  
  // Finally delete the file
  sleep(2); // Not sure if this sleep is necesary, but it seems to be
  file_delete($filepath);
  
  // Set message to say that we're doing the rebuild
  drupal_set_message(t(LEFTANDRIGHT_REBUILDING).' '.check_plain($vocabulary->name));
}