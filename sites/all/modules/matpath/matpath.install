<?php
/**
 * This file helps with the install of the autotag module.  All it does is sets the highest node ID for 
 * nodes which cron will search.  Cron eventually becomes unnecessary for this module.
 */
/**
 * Implementation of hook_install
 */
function matpath_install(){
  $results = array();
  switch ($GLOBALS['db_type']){
    case 'mysql':
    case 'mysqli':
      $results[] = db_query("CREATE TABLE {matpath} (
        tid INT(10),
        vid INT(10),
        path LONGTEXT,
        depth INT(4)
      )");
      // It's a shame that we can't add a UNIQUE index to path/tid here,
      // but MySQL complains that the field is too long (or the field length
      // isn't defined).
      $results[] = db_query("CREATE INDEX {matpath_path} ON {matpath} (path)");
      $results[] = db_query("CREATE INDEX {matpath_tid} ON {matpath} (tid)");
      $results[] = db_query("CREATE INDEX {matpath_vid} ON {matpath} (vid)");
      $results[] = db_query("CREATE INDEX {matpath_depth} ON {matpath} (depth)");
      break;
    case 'pgsql':
      drupal_set_message('error','matpath\'s authors are too lazy to support PostgreSQL');
      return;
      break;
  }
  // Check the results, only going on if they're all alright  
  if (count($result) != count(array_filter($result))) {
  	drupal_set_message(t('Drupal was unable to install the database tables for the matpath module.'), 'error');
  	return;
  }
  // Lets now initiate a tree rebuild for all the vocabularies on the site
  $vocabularies = taxonomy_get_vocabularies();
  foreach($vocabularies as $vocabulary){
    // Rather annoyingly, at this point the module file isn't known to Drupal, so 
    // we have to include it
    include_once('matpath.module');
    matpath_rebuild_tree($vocabulary->vid);
  }
  drupal_set_message(t('Matpath module has been installed, and a full tree rebuild has been started'));
}

function matpath_uninstall(){
  db_query("DROP TABLE {matpath}");
}