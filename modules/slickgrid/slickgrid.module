<?php
/*********************************************************************************************
 * 
 * CONSTANTS
 * 
 ********************************************************************************************/
define('SLICKGRID_CALLBACK_PATH', 'slickgrid/callback');

/*********************************************************************************************
 * 
 * HOOKS
 * 
 ********************************************************************************************/
/** 
 * Implementation of hook_menu(). 
 */
function slickgrid_menu(){
  // Menu callbacks
  $items[SLICKGRID_CALLBACK_PATH . '/%'] = array(
    'page callback' => 'slickgrid_callback',
    'page arguments' => array(
      2
    ),
    'access arguments' => array(
      'access content'
    ),
    'type' => MENU_CALLBACK,
    'file' => 'slickgrid.callbacks.inc'
  );
  return $items;
}

/**
 * Implementation of hook_views_api
 */
function slickgrid_views_api(){
  return array(
    'api' => 2
  );
}

/**
 * Implementation of hook_views_pre_view
 * Slickgrid handles the paging internally so need to override 
 * @param object $view 
 * @return void
 * @author Ben Scott
 */
function slickgrid_views_pre_view(&$view, $display_id){
  // TODO - Can this be moved into the views style plugin? See plugins.inc
  // Is this view a slickgrid view
  if($view->display_handler->get_option('style_plugin') == 'slickgrid'){
    // turn off views paging
    $view->display_handler->set_option('use_pager', FALSE);
    // Need to have all rows returned for slickgrid to work correctly, so turn off items per page
    $view->display_handler->set_option('items_per_page', FALSE);
    // let slickgrid know we want to use it's own paging system by setting it as a view style option		
    $style_options = $view->display_handler->get_option('style_options');
    $style_options['pager'] = TRUE;
    $view->display_handler->set_option('style_options', $style_options);
    // If this is using a collapsible taxonomy field, we need to ensure the nodes are in the right order, and the parent TID is available
    // Much faster to do it now than in a preprocesser after the view data has been constructed
    if($style_options['collapsible_taxonomy_field']){
      // Define the parent relationship 
      $parent_relationship = array(
        'label' => t('Slickgrid parent'),
        'required' => 0,
        'id' => 'parent',
        'table' => 'term_hierarchy',
        'field' => 'parent'
      );
      $view->set_item($display_id, 'relationship', 'slickgrid_parent_relationship', $parent_relationship);
      // Ensure the tid of the parent term is available but hidden from the view
      $parent_tid_field = array(
        'exclude' => 1,
        'id' => 'slickgrid_parent_tid',
        'table' => 'term_data',
        'field' => 'tid',
        'relationship' => 'slickgrid_parent_relationship'
      );
      $view->set_item($display_id, 'field', 'slickgrid_parent_tid', $parent_tid_field);
      // Ensure the tid of the actual term is available but hidden from the view
      $tid_field = array(
        'exclude' => 1,
        'id' => 'slickgrid_tid',
        'table' => 'term_data',
        'field' => 'tid'
      );
      $view->set_item($display_id, 'field', 'slickgrid_tid', $tid_field);
      // The taxonomy sorts need to come first - so remove the exisitng sorts & re-add them after my own 
      $existing_sorts = $view->get_items('sort');
      // Unset all the existing sorts
      foreach(array_keys($existing_sorts) as $existing_sort_id){
        $view->set_item($display_id, 'sort', $existing_sort_id);
      }
      // Add two sorts to the view - one for the parent term, one for the child
      foreach(array(
        'slickgrid_parent_relationship',
        'none'
      ) as $relationship){
        $id = 'slickgrid_sort_' . $relationship;
        $sort = array(
          'order' => 'ASC',
          'id' => $relationship,
          'table' => 'term_data',
          'field' => 'weight',
          'relationship' => $relationship
        );
        $view->set_item($display_id, 'sort', $id, $sort);
      }
      // Re add the original sorts
      // Unset all the existing sorts
      foreach($existing_sorts as $existing_sort_id => $existing_sort){
        $view->set_item($display_id, 'sort', $existing_sort_id, $existing_sort);
      }
    }
  }
}

/** 
 * Implementation of hook_theme(). 
 */
function slickgrid_theme(){
  return array(
    // Display the matrix editor
    'slickgrid' => array(
      'arguments' => array(
        'options' => array(),
        'columns' => array(),
        'data' => array()
      )
    ),
    'slickgrid_views_plugin_table' => array(
      'arguments' => array(
        'form' => array()
      )
    )
  );
}

/**
 * Implementation of hook_slickgrid_plugins().
 */
function slickgrid_slickgrid_plugins(){
  $path = drupal_get_path('module', 'slickgrid');
  $plugins = array(
    'TextCellEditor' => array(
      'description' => t('Text cell'),
      'js' => $path . '/js/slickgrid.editors.js',
      'css' => $path . '/css/slickgrid.editors.css',
      'field_type' => array(
        'text_textfield',
        'text_textarea',
        'node_title'
      ), // Need to only allow for certain field types.
      'plugin_type' => 'editor'
    ),
    'LongTextCellEditor' => array(
      'description' => t('Simple textarea'),
      'js' => $path . '/js/slickgrid.editors.js',
      'css' => $path . '/css/slickgrid.editors.css',
      'field_type' => array(
        'text_textarea',
        'node_revisions_body'
      ),
      'plugin_type' => 'editor'
    ),
    'nodeFormEditor' => array(
      'description' => t('Popup node form'),
      'js' => $path . '/js/slickgrid.editors.js',
      'css' => $path . '/css/slickgrid.editors.css',
      'plugin_type' => 'editor'
    ),
    'requiredFieldValidator' => array(
      'description' => t('Required field'),
      'js' => $path . '/js/slickgrid.validators.js',
      'plugin_type' => 'validator'
    ), //    	'field_type' => array() // Works for all fields types
    // Validators
    'textFilter' => array(
      'description' => t('Text filter'),
      'js' => $path . '/js/slickgrid.filters.js',
      'plugin_type' => 'filter'
    ) //    	'field_type' => array() // Works for all fields types
  );
  return $plugins;
}

/** 
 * Implementation of hook_user(). 
 */
function slickgrid_user($op, &$edit, &$account, $category = NULL){
  switch($op){
    case 'delete':
      // User is being deleted - remove any slickgrid settings
      slickgrid_delete_settings(array(
        'uid' => $account->uid
      ));
      break;
  }
}

/*********************************************************************************************
 * 
 * PREPROCESSOR FUNCTIONS
 * 
 ********************************************************************************************/
/**
 * Preprocessor for views-view-slickgrid.tpl.php
 * Repurpose the views result for slickgrid
 */
function slickgrid_preprocess_views_view_slickgrid(&$vars){
  global $user;
  $view = $vars['view'];
  // Add settings we'll need client side
  drupal_add_js(array(
    'slickgrid' => array(
      'callback_uri' => url('matrix_editor/callback/' . $view->name),
      'path' => drupal_get_path('module', 'slickgrid'),
      'view_name' => $view->name
    )
  ));
  // Get any view settings
  $view->style_plugin->options['settings'] = slickgrid_get_settings($user->uid, $view->name);
  // Set header height default
  $view->style_plugin->options['headerHeight'] = 42;
  // Add some extra slickgrid options here
  $view->style_plugin->options['enableCellNavigation'] = $view->style_plugin->options['editable'];
  $view->style_plugin->options['enableAddRow'] = false;
  // Overide view height option if it's been set by user
  if(is_numeric($view->style_plugin->options['settings']['viewport_height'])){
    $view->style_plugin->options['viewport_height'] = $view->style_plugin->options['settings']['viewport_height'];
  }
  // Overide forceFitColumns option if it's been set by user
  if(isset($view->style_plugin->options['settings']['forceFitColumns'])){
    $view->style_plugin->options['forceFitColumns'] = (int)$view->style_plugin->options['settings']['forceFitColumns'];
  }
  $result = $vars['rows'];
  $handler = $view->style_plugin;
  $handlers = $view->style_plugin->display->handler->get_handlers('field');
  $fields = &$view->field;
  $ordered_columns = array();
  $unordered_columns = array();
  // Build the slickgrid columns  
  foreach($handlers as $field => $handler){
    // If this field is ecluded from the display, continue to the next one
    if($handler->options['exclude']){
      continue;
    }
    if(!$name = $handler->label()){
      $name = $handler->ui_name();
    }
    ($handler->content_field['field_name'] ? $id = $handler->content_field['field_name'] : $id = $field);
    // Get the column width
    if($view->style_plugin->options['settings']['column_width'][$field]){ // UI column resized
      $column_width = $view->style_plugin->options['settings']['column_width'][$field];
    }elseif($view->style_plugin->options['columns'][$field]['width']){ // width set from within the view
      $column_width = $view->style_plugin->options['columns'][$field]['width'];
    }else{
      $column_width = 100; // default width for all unset columns
    }
    $column = array(
      'id' => $id, // The ID of the field from the view
      'name' => $name, // Column title / label
      'field' => $field, // The CCK / Node field name
      'width' => $column_width,
      'cssClass' => 'cell-title',
      'resizable' => ($view->style_plugin->options['enableColumnResize'] ? 1 : 0),
      'args' => ''
    );
    
    dd($column);
    
    // Is this a CCK field?
    if($handler->content_field['widget']['type']){
      $column['id'] = $handler->content_field['field_name'];
       //      $column['field'] = $handler->content_field['field_name'];
    }elseif(count($handler->options['vids'])){
      foreach($handler->options['vids'] as $vid){
        if($vid){
          $column['args'] .= 'vids[]=' . $vid . '&';
        }
      }
    }
    // Is this field being filtered?
    // If any fields require filtering, we need to let the JS know
    if($view->style_plugin->options['columns'][$field]['filter']){
      $view->style_plugin->options['has_filters'] = TRUE;
      // Add a header row for the filters
      // Don't add a headerRow if the filter is set on a taxonomy filter field - this won't require a header row
      if($view->style_plugin->options['collapsible_taxonomy_field'] != $field){
        $view->style_plugin->options['showHeaderRow'] = TRUE;
      }
    }
    // Loop through all the plugin types and see if it's been set for this column
    foreach(array_keys(slickgrid_get_plugin_types()) as $plugin_type){
      // Is there an plugin defined for this column
      if($view->style_plugin->options['columns'][$field][$plugin_type]){
        $column[$plugin_type] = $view->style_plugin->options['columns'][$field][$plugin_type];
        // If just one column is editable, turn on editable & cell navigation for the grid
        if($plugin_type == 'editor'){
          $view->style_plugin->options['editable'] = TRUE;
          $view->style_plugin->options['enableCellNavigation'] = TRUE;
        }
      }
    }
    // Is this field sortable?
    // If any fields are sortable, set style option so we can access it in the js
    // DO NOT turn on sortable columns if collapsible_taxonomy_field is set - they are not compatible
    if($view->style_plugin->options['columns'][$field]['sortable'] & !$view->style_plugin->options['collapsible_taxonomy_field']){
      $view->style_plugin->options['sortable_columns'] = TRUE;
      $column['sortable'] = 1;
    }
    // Is this using the collapsible tree formatter plugin?
    if($view->style_plugin->options['collapsible_taxonomy_field'] == $field){
      // Set the filters & formatters for the collapsible field column
      $view->style_plugin->options['columns'][$field]['filter'] = $column['filter'] = 'collapsibleFilter';
      $view->style_plugin->options['columns'][$field]['formatter'] = $column['formatter'] = 'collapsibleFormatter';
    }
    // We need to know the column label for the group by function in JS
    // Add it to the views plugin options so we can access it efficiantly (otherwise I'll need to loop thru columns array)
    $view->style_plugin->options['columns'][$field]['label'] = $name;
    if(is_array($view->style_plugin->options['settings']['ordered_columns']) && is_numeric($ordered_column_position = array_search($field, $view->style_plugin->options['settings']['ordered_columns']))){ // This is an ordered column
      $ordered_columns[$ordered_column_position] = $column;
    }else{ // There is no ordering for this column
      $unordered_columns[] = $column;
    }
  }
  ksort($ordered_columns);
  // Merge ordered & unordered columns 
  // Any unordered columns are added to the end to allow for new columns added through the view
  $columns = array_merge($ordered_columns, $unordered_columns);
  // Construct the slickgrid data array	
  $keys = array_keys($view->field);
  $data = array();
  $parents = array(); // array of tid => array(nid => nid, indent => indent) so we can retrive the nid & indentation of a parent node
  foreach($result as $count => $row){
    // Add the data fields
    foreach($keys as $id){
    	dd($id);
      if(!($view->field[$id]->options['exclude'])){
        $data[$count][$id] = $view->field[$id]->theme($row);
      }
    }
    $data[$count]['id'] = $row->nid;
    // If this has collapsible_taxonomy_field set, we will have added slickgrid_parent_tid & slickgrid_tid in hook_views_pre_view
    // These are aliased in $row so get the field aliases
    if(property_exists($row, $view->field['slickgrid_tid']->field_alias) && $slickgrid_tid = $row->{$view->field['slickgrid_tid']->field_alias}){
      if($parent = $parents[$row->{$view->field['slickgrid_parent_tid']->field_alias}]){
        // If we can find a parent, set the parent nid & indentation++
        $data[$count]['indent'] = $parent['indent'] + 1;
        $data[$count]['parent'] = $parent['nid'];
      }else{
        // Otherwise set indent & parent to 0 - this breaks if left blank
        $data[$count]['indent'] = 0;
        $data[$count]['parent'] = 0;
      }
      // Store the indent & nid so then can be used to calculate child term indentation 
      $parents[$slickgrid_tid] = array(
        'nid' => $row->nid,
        'indent' => $data[$count]['indent']
      );
    }
  }
  $vars['slickgrid'] = theme('slickgrid', $view->style_plugin->options, $columns, $data, $view);
}

/*********************************************************************************************
 * 
 * THEME FUNCTIONS
 * 
 ********************************************************************************************/
/**
 * The main theme function for the slickgrid
 * @param array $options
 * @param array $columns
 * @param array $data
 * @param array $view_name
 */
function theme_slickgrid($options, $columns, $data, $view){
  $output = '';
  // Add all the CSS & JS
  _slickgrid_add_files($options, $columns);
  $js = array();
  $js[] = 'var options = ' . drupal_to_js($options) . ';';
  $js[] = 'var data = []; data = ' . drupal_to_js($data) . ';';
  $js[] = 'var columns = ' . _slickgrid_drupal_to_js($columns) . ';';
  $js[] = 'var slickgrid;';
  $js[] = '$(function() { slickgrid = new Slickgrid("#slickgrid", "' . $view->name . '", "' . $view->current_display . '", "' . url(SLICKGRID_CALLBACK_PATH) . '"); })';
  drupal_add_js(implode("\n", $js), 'inline');
  // Adjust hieght to allow for scrollbar
  // output a placeholder div for the slickgrid
  $output .= '<div id="slickgrid" style="width:100%;height:' . $options['viewport_height'] . 'px;" class="hideCols hideRows ' . ($options['editable'] ? 'editable' : '') . '"></div>';
  $output .= '<div id="controls">';
  if($options['pager']){
    $output .= '<div id="slickgrid-pager"></div>';
  }
  if($options['undo']){
    $output .= '<div id="slickgrid-undo"></div>';
  }
  $output .= '<div id="slickgrid-status"></div>';
  $output .= '<div id="slickgrid-loading-bar"></div>';
  $output .= '</div>';
  if($options['delete_nodes']){
    $output .= '<ul id="contextMenu" style="display:none;position:absolute"><li>Delete row</li></ul>';
  }
  return $output;
}

/**
 * Theme the form for the matrix style plugin
 */
function theme_slickgrid_views_plugin_table($form){
  $output = drupal_render($form['description_markup']);
  $header = array(
    t('Field'),
    t('Width'),
    t('Sortable')
  );
  $rows = array();
  $plugin_types = slickgrid_get_plugin_types();
  $header += $plugin_types;
  foreach(element_children($form['columns']) as $id){
    $row = array();
    $row[] = drupal_render($form['columns'][$id]['name']);
    $row[] = drupal_render($form['columns'][$id]['width']);
    $row[] = drupal_render($form['columns'][$id]['sortable']);
    foreach(array_keys($plugin_types) as $plugin_type){
      $row[] = drupal_render($form['columns'][$id][$plugin_type]);
    }
    $rows[] = $row;
  }
  $output .= theme('table', $header, $rows);
  $output .= drupal_render($form);
  return $output;
}

/*********************************************************************************************
 * 
 * DAO GET / SETTERS
 * 
 ********************************************************************************************/
function slickgrid_set_settings($view_name, $setting, $value){
  global $user;
  if($user->uid){
    $record = new stdClass();
    $record->uid = $user->uid;
    $record->view_name = $view_name;
    if($record->settings = slickgrid_get_settings($user->uid, $view_name)){
      $update = array(
        'uid',
        'view_name'
      );
    }else{
      $update = array();
    }
    $record->settings[$setting] = $value;
    $record->settings = serialize($record->settings);
    drupal_write_record('slickgrid', $record, $update);
  }
}

/**
 * 
 * Get settings from the DB
 * Pass in $setting to retrieve a particular setting, NULL to get akll for a UID / View
 * @param string $uid
 * @param string $view_name
 * @param string $setting
 */
function slickgrid_get_settings($uid, $view_name, $setting = null){
  $settings = unserialize(db_result(db_query("SELECT settings FROM {slickgrid} WHERE uid = %d AND view_name = '%s'", $uid, $view_name)));
  if($setting){
    return $settings[$setting];
  }else{
    return $settings;
  }
}

/**
 * Delete settings from the database
 * @param array $params
 * Can be any key value pair where key is the table field, value is the value (like UID, view name) to retrieve
 */
function slickgrid_delete_settings($params){
  $conj = '';
  if(count($params)){
    $sql = 'DELETE FROM {slickgrid} WHERE ';
    foreach($params as $field => $param){
      $sql .= $conj . $field . ' = "%s"';
      $conj = ' AND ';
    }
    db_query($sql, $params);
  }
}

/*********************************************************************************************
 * 
 * HELPER FUNCTIONS
 * 
 ********************************************************************************************/
function _slickgrid_add_files($options, $columns){
  $path = drupal_get_path('module', 'slickgrid');
  drupal_add_js($path . '/js/slickgrid/lib/jquery-1.4.3.min.js');
  // Add slickgrid dependencies
  drupal_add_js($path . '/js/slickgrid/lib/firebugx.js');
  drupal_add_js($path . '/js/slickgrid/lib/jquery.event.drag-2.0.min.js');
  // Add the slickgrid files
  drupal_add_js($path . '/js/slickgrid/slick.core.js');
  drupal_add_js($path . '/js/slickgrid/slick.dataview.js');
  drupal_add_js($path . '/js/slickgrid/slick.grid.js');
  drupal_add_css($path . '/js/slickgrid/slick.grid.css');
  // Add jQuery UI files
  // Uses the UI files included in slickgrid to ensure compatibility 
  // TODO Make this work with the jquery.ui module
  drupal_add_js($path . '/js/slickgrid/lib/jquery-ui-1.8.5.custom.min.js');
  drupal_add_css($path . '/js/slickgrid/css/smoothness/jquery-ui-1.8.5.custom.css');
  // Depending on options slected for the view, enable slickgrid plugins
  // Is check box select column enabled?
  if($options['multi_edit']){
    drupal_add_js($path . '/js/slickgrid/plugins/slick.checkboxselectcolumn.js');
    drupal_add_js($path . '/js/slickgrid/plugins/slick.rowselectionmodel.js');
  }
  // Depending on options selected, enable controls (pager, show / hide column headers)
  if($options['pager']){
    drupal_add_js($path . '/js/slickgrid/controls/slick.pager.js');
    drupal_add_css($path . '/js/slickgrid/controls/slick.pager.css');
  }
  // Can user select which columns to display
  if($options['select_columns']){
    drupal_add_js($path . '/js/slickgrid/controls/slick.columnpicker.js');
    drupal_add_css($path . '/js/slickgrid/controls/slick.columnpicker.css');
  }
  // Add groups UI js file - adds buttons to expand / collpase all
  if($options['grouping_field']){
    drupal_add_js($path . '/js/slickgrid.groups-ui.js');
  }
  if($options['collapsible_taxonomy_field']){
    drupal_add_js($path . '/js/slickgrid.collapsible.js');
  }
  $slickgrid_plugins = slickgrid_get_plugins();
  // Need to add all the files associated with plugins
  // Loop through all the columns
  foreach($columns as $column){
    foreach(array_keys(slickgrid_get_plugin_types()) as $plugin_type){
      // Does this column have this type of plugin defined? And is there as JS file?
      if(isset($column[$plugin_type])){
        if(isset($slickgrid_plugins[$column[$plugin_type]]['js'])){
          drupal_add_js($slickgrid_plugins[$column[$plugin_type]]['js']);
        }
        if(isset($slickgrid_plugins[$column[$plugin_type]]['css'])){
          drupal_add_css($slickgrid_plugins[$column[$plugin_type]]['css']);
        }
      }
    }
  }
  // Add bespoke slickgrid js/css
  drupal_add_js($path . '/js/slickgrid.js');
  drupal_add_css($path . '/css/slickgrid.css');
  //TODO - remove
  //  drupal_add_css($path . '/js/slickgrid/examples/examples.css');
  // Add beautytips if the module's available
  if(module_exists(beautytips)){
    beautytips_add_beautytips();
  }
}

/** 
 * Amended version of drupal_to_js()
 * Convert a php array into a js string, but allowing for function names (not wrapped in "")
 */
function _slickgrid_drupal_to_js($elements, $additional_function_names = array()){
  $function_names = array(
    'formatter',
    'validator',
    'editor',
    'setValueHandler',
    'resizable'
  );
  if(count($additional_function_names)){
    $function_names += $additional_function_names;
  }
  if(count($elements)){
    $js_string = '[';
    foreach($elements as $element){
      $js_string .= $outer_conjunction . '{';
      foreach($element as $element_name => $element_value){
        $js_string .= $inner_conjunction;
        if(in_array($element_name, $function_names) || is_numeric($element_value) || is_bool($element_value)){
          $js_string .= $element_name . ': ' . $element_value;
        }else{
          $js_string .= $element_name . ': ' . drupal_to_js($element_value);
        }
        $inner_conjunction = ', ';
      } // End of foreach($element)
      $js_string .= '}';
      $inner_conjunction = ' ';
      $outer_conjunction = ', ';
    }
    $js_string .= ']';
    return $js_string;
  }
}

/**
 * Discover all action functions by invoking hook_action_info().
 *
 * @code
 * mymodule_action_info() {
 * return array(
 * 'mymodule_functiondescription_action' => array(
 * 'type' => 'node',
 * 'description' => t('Save node'),
 * 'configurable' => FALSE,
 * 'hooks' => array(
 * 'nodeapi' => array('delete', 'insert', 'update', 'view'),
 * 'comment' => array('delete', 'insert', 'update', 'view'),
 * )
 * )
 * );
 * }
 * @endcode
 *
 * The description is used in presenting possible actions to the user for
 * configuration. The type is used to present these actions in a logical
 * grouping and to denote context. Some types are 'node', 'user', 'comment',
 * and 'system'. If an action is configurable it will provide form,
 * validation and submission functions. The hooks the action supports
 * are declared in the 'hooks' array.
 *
 * @param $reset
 * Reset the action info static cache.
 *
 * @return
 * An associative array keyed on function name. The value of each key is
 * an array containing information about the action, such as type of
 * action and description of the action, e.g.,
 *
 * @code
 * $actions['node_publish_action'] = array(
 * 'type' => 'node',
 * 'description' => t('Publish post'),
 * 'configurable' => FALSE,
 * 'hooks' => array(
 * 'nodeapi' => array('presave', 'insert', 'update', 'view'),
 * 'comment' => array('delete', 'insert', 'update', 'view'),
 * ),
 * );
 * @endcode
 */
function slickgrid_plugins_list($reset = FALSE){
  static $plugins;
  if(!isset($plugins) || $reset){
    $editors = module_invoke_all('slickgrid_plugins');
    drupal_alter('slickgrid_plugins', $editors);
  }
  return (array)$editors;
}

/**
 * 
 * Enter description here ...
 * @param array $filters
 * Array of filters to filter list of plugins 
 * eg: array('plugin_type' => 'editor' will return a list of all editors 
 */
function slickgrid_get_plugins($filters){
  // Get a list of all available plugins 
  $plugins = slickgrid_plugins_list();
  // If they need to be filtered...
  if(is_array($filters)){
    $plugins = slickgrid_filter_plugins($plugins, $filters);
  }
  return $plugins;
}

/**
 * 
 * Return all plugins matching the filters
 * @param array $plugins
 * @param array $filters
 */
function slickgrid_filter_plugins($plugins, $filters){
  // Loop through all of the plugins
  foreach($plugins as $plugin_type => $plugin){
    // Loop through the plugins
    foreach($filters as $property => $value){
      // If the plugin has a property that doesn't match the filter...	
      if((is_array($plugin[$property]) && !in_array($value, $plugin[$property])) || (is_string($plugin[$property]) && $plugin[$property] != $value)){
        // Remove the plugin
        unset($plugins[$plugin_type]);
        // And move onto the next plugin
        break;
      }
    }
  }
  return $plugins;
}

/**
 * 
 * Array of all allowed plugin types
 */
function slickgrid_get_plugin_types(){
  return array(
    'formatter' => t('Formatter'),
    'editor' => t('Editor'),
    'validator' => t('Validator'),
    'filter' => t('Filter')
  );
}

/**
 * Return data in JSON format.
 * Using drupal_json() results in a parse error client side on some html content
 * So use json_encode instead
 * 
 * @param $var
 * (optional) If set, the variable will be converted to JSON and output.
 */
function slickgrid_json($var = NULL){
  drupal_set_header('Content-Type: text/javascript; charset=utf-8');
  if(isset($var)){
    echo json_encode($var);
  }
  exit();
}


